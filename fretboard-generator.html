<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>指板図ジェネレーター</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        .container {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        select, input, button {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #333;
            color: #e0e0e0;
            font-size: 14px;
        }
        button {
            cursor: pointer;
            background-color: #4a9eff;
            border: none;
            color: white;
        }
        button:hover {
            background-color: #3a8eef;
        }
        #fretboard {
            background-color: #1a1a1a;
            border: 2px solid #444;
            border-radius: 4px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }
        #fretboard svg {
            max-width: 100%;
            height: auto;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #666;
        }
        .root { background-color: #ff4444; }
        .third { background-color: #4444ff; }
        .fifth { background-color: #44ff44; }
        .seventh { background-color: #ffff44; }
        .dim5 { background-color: #ff44ff; }
        .aug5 { background-color: #ff8844; }
        .sus2 { background-color: #44ffff; }
        .sus4 { background-color: #ffaa44; }
        .ninth { background-color: #aa44ff; }
        .sixth { background-color: #44ffaa; }
        
        /* トグルスイッチのスタイル */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #4a9eff;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        .toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>指板図ジェネレーター</h1>
        <div class="controls">
            <label>
                キー:
                <select id="keySelect">
                    <option value="C">C</option>
                    <option value="C#">C# / Db</option>
                    <option value="D">D</option>
                    <option value="D#">D# / Eb</option>
                    <option value="E">E</option>
                    <option value="F">F</option>
                    <option value="F#">F# / Gb</option>
                    <option value="G">G</option>
                    <option value="G#">G# / Ab</option>
                    <option value="A" selected>A</option>
                    <option value="A#">A# / Bb</option>
                    <option value="B">B</option>
                </select>
            </label>
            <label>
                コード種別:
                <select id="chordTypeSelect">
                    <optgroup label="基本">
                        <option value="major" selected>メジャー</option>
                        <option value="minor">マイナー</option>
                        <option value="7">7th (ドミナント)</option>
                        <option value="m7">m7 (マイナー7th)</option>
                        <option value="maj7">maj7 (メジャー7th)</option>
                    </optgroup>
                    <optgroup label="ディミニッシュ/オーグメント">
                        <option value="dim">dim (ディミニッシュ)</option>
                        <option value="dim7">dim7 (ディミニッシュ7th)</option>
                        <option value="m7b5">m7(b5) (ハーフディミニッシュ)</option>
                        <option value="aug">aug (オーグメント)</option>
                    </optgroup>
                    <optgroup label="サスペンド">
                        <option value="sus2">sus2</option>
                        <option value="sus4">sus4</option>
                        <option value="7sus4">7sus4</option>
                    </optgroup>
                    <optgroup label="6th">
                        <option value="6">6</option>
                        <option value="m6">m6</option>
                    </optgroup>
                    <optgroup label="拡張コード">
                        <option value="add9">add9</option>
                        <option value="madd9">m(add9)</option>
                        <option value="9">9</option>
                        <option value="m9">m9</option>
                        <option value="maj9">maj9</option>
                    </optgroup>
                </select>
            </label>
            <label>
                開始フレット:
                <input type="number" id="startFret" value="0" min="0" max="12">
            </label>
            <label>
                終了フレット:
                <input type="number" id="endFret" value="12" min="0" max="24">
            </label>
            <label class="toggle-label">
                セブンス表示:
                <label class="toggle-switch">
                    <input type="checkbox" id="seventhModeToggle">
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <label id="allModeToggleLabel" style="display: none;">
                全ポジション表示:
                <label class="toggle-switch">
                    <input type="checkbox" id="allModeToggle">
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <label>
                チューニング:
                <select id="tuningSelect">
                    <option value="standard" selected>標準チューニング (E A D G B E)</option>
                    <option value="halfStepDown">半音下げ (Eb Ab Db Gb Bb Eb)</option>
                </select>
            </label>
            <label class="toggle-label">
                実フレット間隔:
                <label class="toggle-switch">
                    <input type="checkbox" id="realisticFretSpacing" checked>
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <label class="toggle-label">
                凡例（表示中のみ）:
                <label class="toggle-switch">
                    <input type="checkbox" id="legendModeToggle">
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <label>
                ポジションマーク形状:
                <select id="positionMarkShape">
                    <option value="fender" selected>フェンダー（丸）</option>
                    <option value="gibson">レスポールカスタム（ブロック）</option>
                    <option value="lespaul">レスポールスタンダード（台形）</option>
                    <option value="diamond">ダイヤモンド</option>
                    <option value="rectangle">長方形</option>
                </select>
            </label>
            <label>
                ポジションマーク濃度:
                <input type="range" id="positionMarkOpacity" min="0" max="100" value="20" style="width: 100px;">
                <span id="positionMarkOpacityValue">20%</span>
            </label>
            <label>
                ポジションマーク色:
                <select id="positionMarkColor">
                    <option value="#bbb">ライトグレー (現在)</option>
                    <option value="#888">ミディアムグレー</option>
                    <option value="#6a5a4a">ローズウッド</option>
                    <option value="#5a6a6a">ダークティール</option>
                    <option value="#6a5a7a">ダークパープル</option>
                    <option value="#7a6a3a">ゴールド/アンバー</option>
                    <option value="#5a3a3a">ダークレッド</option>
                    <option value="#3a5a4a">ダークグリーン</option>
                </select>
            </label>
            <label>
                スケールキー:
                <select id="scaleKey">
                    <option value="C">C</option>
                    <option value="C#">C#</option>
                    <option value="Db">Db</option>
                    <option value="D">D</option>
                    <option value="D#">D#</option>
                    <option value="Eb">Eb</option>
                    <option value="E">E</option>
                    <option value="F">F</option>
                    <option value="F#">F#</option>
                    <option value="Gb">Gb</option>
                    <option value="G">G</option>
                    <option value="G#">G#</option>
                    <option value="Ab">Ab</option>
                    <option value="A">A</option>
                    <option value="A#">A#</option>
                    <option value="Bb">Bb</option>
                    <option value="B">B</option>
                </select>
            </label>
            <label>
                スケールタイプ:
                <select id="scaleType">
                    <option value="none">なし</option>
                    <option value="major">メジャースケール</option>
                    <option value="minor">ナチュラルマイナースケール</option>
                    <option value="pentatonicMajor">メジャーペンタトニック</option>
                    <option value="pentatonicMinor">マイナーペンタトニック</option>
                    <option value="dorian">ドリアンスケール</option>
                    <option value="mixolydian">ミクソリディアンスケール</option>
                </select>
            </label>
            <button onclick="downloadSVG()">SVGダウンロード</button>
            <button onclick="downloadPNG()">PNGダウンロード</button>
        </div>
    </div>

    <div class="container">
        <div id="fretboard"></div>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-dot root"></div>
                <span>ルート</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot third"></div>
                <span>3rd</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot fifth"></div>
                <span>5th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot seventh"></div>
                <span>7th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot dim5"></div>
                <span>♭5th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot aug5"></div>
                <span>#5th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot sus2"></div>
                <span>2nd</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot sus4"></div>
                <span>4th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot ninth"></div>
                <span>9th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot sixth"></div>
                <span>6th</span>
            </div>
        </div>
    </div>

    <script>
        // チューニングの定義
        const tunings = {
            standard: {
                strings: ['E', 'B', 'G', 'D', 'A', 'E'], // 1弦(高音E) → 6弦(低音E)
                stringNotes: [4, 11, 7, 2, 9, 4] // MIDI note numbers (1弦→6弦の順)
            },
            halfStepDown: {
                strings: ['Eb', 'Bb', 'Gb', 'Db', 'Ab', 'Eb'], // 1弦(高音Eb) → 6弦(低音Eb)
                stringNotes: [3, 10, 6, 1, 8, 3] // MIDI note numbers (1弦→6弦の順)
            }
        };
        
        // 現在のチューニングを取得する関数
        function getCurrentTuning() {
            const tuningType = document.getElementById('tuningSelect')?.value || 'standard';
            return tunings[tuningType];
        }

        // スケールの定義（半音数の配列）
        const scalePatterns = {
            major: [0, 2, 4, 5, 7, 9, 11], // メジャースケール
            minor: [0, 2, 3, 5, 7, 8, 10], // ナチュラルマイナースケール
            pentatonicMajor: [0, 2, 4, 7, 9], // メジャーペンタトニック
            pentatonicMinor: [0, 3, 5, 7, 10], // マイナーペンタトニック
            dorian: [0, 2, 3, 5, 7, 9, 10], // ドリアンスケール
            mixolydian: [0, 2, 4, 5, 7, 9, 10] // ミクソリディアンスケール
        };
        
        // スケールトーンを取得する関数
        function getScaleNotes(key, scaleType) {
            if (!scaleType || scaleType === 'none') return [];
            
            const pattern = scalePatterns[scaleType];
            if (!pattern) return [];
            
            const keySemitone = noteToSemitone[key];
            if (keySemitone === undefined) return [];
            
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const scaleNotes = pattern.map(interval => {
                const semitone = (keySemitone + interval) % 12;
                return noteNames[semitone];
            });
            
            return scaleNotes;
        }
        
        // コードトーンの定義
        // コード種別のインターバルパターン（半音単位）
        // 各プロパティは [音程タイプ, 半音数] のペア
        const chordTypePatterns = {
            // 基本
            'major':  { intervals: { root: 0, third: 4, fifth: 7 } },
            'minor':  { intervals: { root: 0, third: 3, fifth: 7 } },
            '7':      { intervals: { root: 0, third: 4, fifth: 7, seventh: 10 } },
            'm7':     { intervals: { root: 0, third: 3, fifth: 7, seventh: 10 } },
            'maj7':   { intervals: { root: 0, third: 4, fifth: 7, seventh: 11 } },
            // ディミニッシュ/オーグメント
            'dim':    { intervals: { root: 0, third: 3, dim5: 6 } },
            'dim7':   { intervals: { root: 0, third: 3, dim5: 6, sixth: 9 } },
            'm7b5':   { intervals: { root: 0, third: 3, dim5: 6, seventh: 10 } },
            'aug':    { intervals: { root: 0, third: 4, aug5: 8 } },
            // サスペンド
            'sus2':   { intervals: { root: 0, sus2: 2, fifth: 7 } },
            'sus4':   { intervals: { root: 0, sus4: 5, fifth: 7 } },
            '7sus4':  { intervals: { root: 0, sus4: 5, fifth: 7, seventh: 10 } },
            // 6th
            '6':      { intervals: { root: 0, third: 4, fifth: 7, sixth: 9 } },
            'm6':     { intervals: { root: 0, third: 3, fifth: 7, sixth: 9 } },
            // 拡張コード
            'add9':   { intervals: { root: 0, third: 4, fifth: 7, ninth: 14 } },
            'madd9':  { intervals: { root: 0, third: 3, fifth: 7, ninth: 14 } },
            '9':      { intervals: { root: 0, third: 4, fifth: 7, seventh: 10, ninth: 14 } },
            'm9':     { intervals: { root: 0, third: 3, fifth: 7, seventh: 10, ninth: 14 } },
            'maj9':   { intervals: { root: 0, third: 4, fifth: 7, seventh: 11, ninth: 14 } }
        };
        
        // 音名の配列（シャープ系）
        const noteNamesSharp = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        // 音名の配列（フラット系）
        const noteNamesFlat = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
        
        // キーがフラット系かどうかを判定
        function useFlatNotation(key) {
            // フラット系のキー: F, Bb, Eb, Ab, Db, Gb と、マイナーキー Dm, Gm, Cm, Fm, Bbm, Ebm
            const flatKeys = ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'D#', 'G#', 'A#'];
            return flatKeys.includes(key);
        }
        
        // キーとコード種別からコードトーンを計算
        function getChordTones(key, chordType) {
            const pattern = chordTypePatterns[chordType];
            if (!pattern) return null;
            
            const keyIndex = noteNamesSharp.indexOf(key) !== -1 
                ? noteNamesSharp.indexOf(key) 
                : noteNamesFlat.indexOf(key);
            
            if (keyIndex === -1) return null;
            
            const useFlat = useFlatNotation(key);
            const noteNames = useFlat ? noteNamesFlat : noteNamesSharp;
            
            const tones = {};
            for (const [toneType, semitones] of Object.entries(pattern.intervals)) {
                const noteIndex = (keyIndex + semitones) % 12;
                tones[toneType] = noteNames[noteIndex];
            }
            
            return tones;
        }
        
        // 現在選択されているコード情報を取得
        function getCurrentChord() {
            const key = document.getElementById('keySelect').value;
            const chordType = document.getElementById('chordTypeSelect').value;
            return { key, chordType, name: key + (chordType === 'major' ? '' : chordType) };
        }

        // 音名を半音数に変換
        const noteToSemitone = {
            'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
            'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
            'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
        };
        
        // 異名同音のマッピング（Eb = D#, Gb = F#など）
        const enharmonicMap = {
            'Eb': 'D#', 'D#': 'Eb',
            'Gb': 'F#', 'F#': 'Gb',
            'Ab': 'G#', 'G#': 'Ab',
            'Bb': 'A#', 'A#': 'Bb',
            'Db': 'C#', 'C#': 'Db'
        };

        function getNoteAtPosition(stringIndex, fret) {
            const tuning = getCurrentTuning();
            const openNote = tuning.stringNotes[stringIndex];
            const semitone = (openNote + fret) % 12;
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            return noteNames[semitone];
        }
        
        // 異名同音のマッピング（Eb = D#, Gb = F#など）
        function isEnharmonicEquivalent(note1, note2) {
            if (!note1 || !note2) return false; // nullやundefinedの場合はfalse
            if (note1 === note2) return true;
            const enharmonicPairs = {
                'Eb': 'D#', 'D#': 'Eb',
                'Gb': 'F#', 'F#': 'Gb',
                'Ab': 'G#', 'G#': 'Ab',
                'Bb': 'A#', 'A#': 'Bb',
                'Db': 'C#', 'C#': 'Db'
            };
            return enharmonicPairs[note1] === note2 || enharmonicPairs[note2] === note1;
        }

        function getToneType(note, tones) {
            if (!tones || !note) return null;
            
            // 1. コードに定義されているトーンを優先的にチェック（異名同音も考慮）
            if (note === tones.root || isEnharmonicEquivalent(note, tones.root)) return 'root';
            if (note === tones.third || isEnharmonicEquivalent(note, tones.third)) return 'third';
            // fifthはdim5/aug5の前にチェック（通常の5thの場合）
            if (tones.fifth && (note === tones.fifth || isEnharmonicEquivalent(note, tones.fifth))) return 'fifth';
            // dim5とaug5はfifthの後にチェック（dim5/aug5が優先される）
            if (tones.dim5 && (note === tones.dim5 || isEnharmonicEquivalent(note, tones.dim5))) return 'dim5';
            if (tones.aug5 && (note === tones.aug5 || isEnharmonicEquivalent(note, tones.aug5))) return 'aug5';
            if (tones.seventh && (note === tones.seventh || isEnharmonicEquivalent(note, tones.seventh))) return 'seventh';
            if (tones.sus2 && (note === tones.sus2 || isEnharmonicEquivalent(note, tones.sus2))) return 'sus2';
            if (tones.sus4 && (note === tones.sus4 || isEnharmonicEquivalent(note, tones.sus4))) return 'sus4';
            if (tones.ninth && (note === tones.ninth || isEnharmonicEquivalent(note, tones.ninth))) return 'ninth';
            if (tones.sixth && (note === tones.sixth || isEnharmonicEquivalent(note, tones.sixth))) return 'sixth';
            
            // 2. コードに7thが定義されていない場合のみ、ルートから計算した7thを返す
            // これにより、メジャー/マイナーコードでも7thを表示できる
            // メジャーコードの場合はDominant 7th（10半音）、マイナーコードの場合はMinor 7th（10半音）を優先
            if (tones.root && !tones.seventh) {
                const rootSemitone = noteToSemitone[tones.root];
                const noteSemitone = noteToSemitone[note];
                
                // 音名がマッピングに存在することを確認
                if (rootSemitone !== undefined && noteSemitone !== undefined) {
                    const interval = (noteSemitone - rootSemitone + 12) % 12;
                    
                    // 既に他のトーンとして認識されている場合は除外（異名同音も考慮）
                    const isOtherTone = isEnharmonicEquivalent(note, tones.root) || 
                                       isEnharmonicEquivalent(note, tones.third) || 
                                       isEnharmonicEquivalent(note, tones.fifth) ||
                                       (tones.dim5 && isEnharmonicEquivalent(note, tones.dim5)) ||
                                       (tones.aug5 && isEnharmonicEquivalent(note, tones.aug5)) ||
                                       (tones.sus2 && isEnharmonicEquivalent(note, tones.sus2)) ||
                                       (tones.sus4 && isEnharmonicEquivalent(note, tones.sus4));
                    
                    if (isOtherTone) {
                        return null;
                    }
                    
                    // メジャーコード（thirdが存在し、♭3rdでない）の場合はDominant 7th（10半音）のみ
                    // マイナーコード（thirdが♭3rd）の場合もMinor 7th（10半音）のみ
                    // Major 7th（11半音）は通常、明示的にmaj7と指定された場合のみ使用
                    if (interval === 10) {
                        // Minor 7th / Dominant 7th（10半音）
                        return 'seventh';
                    }
                    // interval === 11 (Major 7th) は計算しない（maj7として明示的に定義されている場合のみ表示）
                }
            }
            
            return null;
        }

        // コードトーンを囲む図形を描画
        function drawToneOutlines(svg, tonePositions, displayMode, tones) {
            // 表示するトーンタイプを決定
            let toneTypes = [];
            if (displayMode === 'triad') {
                if (tones.sus2) toneTypes = ['root', 'sus2', 'fifth'];
                else if (tones.sus4) toneTypes = ['root', 'sus4', 'fifth'];
                else if (tones.dim5) toneTypes = ['root', 'third', 'dim5'];
                else if (tones.aug5) toneTypes = ['root', 'third', 'aug5'];
                else toneTypes = ['root', 'third', 'fifth'];
            } else if (displayMode === 'seventh') {
                if (tones.seventh) toneTypes = ['root', 'third', 'fifth', 'seventh'];
                else if (tones.dim5) toneTypes = ['root', 'third', 'dim5'];
                else if (tones.aug5) toneTypes = ['root', 'third', 'aug5'];
                else toneTypes = ['root', 'third', 'fifth'];
            } else {
                // 全ポジション: 利用可能なすべてのトーン
                toneTypes = Object.keys(tonePositions).filter(key => tonePositions[key] && tonePositions[key].length > 0);
            }
            
            // 各トーンタイプのすべてのポジションを1つのグループとして収集
            const allPositions = [];
            toneTypes.forEach(type => {
                if (tonePositions[type] && tonePositions[type].length > 0) {
                    tonePositions[type].forEach(pos => {
                        allPositions.push({ ...pos, type });
                    });
                }
            });
            
            if (allPositions.length < 2) return;
            
            // 近接するポジションをグループ化（同じコードフォーム内）
            const groups = findChordFormGroups(allPositions, toneTypes);
            
            groups.forEach((group) => {
                if (group.length < 2) return;
                
                // ルートを起点として、コードフォームに沿って並べ替え
                const sortedGroup = sortByChordForm(group, toneTypes, tonePositions);
                
                if (sortedGroup.length < 2) return;
                
                // コードフォームに沿った囲みを描画（角を丸く、内側にマージン）
                drawRoundedOutline(svg, sortedGroup);
            });
        }
        
        // コードフォームごとにグループ化（R, 3rd, 5thなどが1つのグループ）
        function findChordFormGroups(allPositions, toneTypes) {
            const groups = [];
            const used = new Set();
            
            // 各ポジションについて、同じコードフォーム内の他のトーンを探す
            allPositions.forEach(pos => {
                const key = `${pos.string}-${pos.fret}`;
                if (used.has(key)) return;
                
                const group = [pos];
                used.add(key);
                
                // 同じコードフォーム内の他のトーンを探す
                // 近接する範囲内（6フレット、4弦以内）で、必要なトーンタイプがすべて揃っているか確認
                const fretRange = 6;
                const stringRange = 4;
                
                // このポジションを中心に、必要なトーンタイプがすべて揃っているグループを探す
                const nearbyPositions = allPositions.filter(other => {
                    const otherKey = `${other.string}-${other.fret}`;
                    if (used.has(otherKey)) return false;
                    
                    const fretDiff = Math.abs(pos.fret - other.fret);
                    const stringDiff = Math.abs(pos.string - other.string);
                    return fretDiff <= fretRange && stringDiff <= stringRange;
                });
                
                // 必要なトーンタイプがすべて揃っているか確認
                const foundTypes = new Set([pos.type]);
                nearbyPositions.forEach(other => {
                    foundTypes.add(other.type);
                });
                
                // 必要なトーンタイプがすべて揃っている場合、グループに追加
                const hasAllTypes = toneTypes.every(type => foundTypes.has(type));
                
                if (hasAllTypes) {
                    // 各トーンタイプから最も近いポジションを1つずつ選ぶ
                    const selectedPositions = [pos];
                    toneTypes.forEach(type => {
                        if (type === pos.type) return; // 既に追加済み
                        
                        const candidates = nearbyPositions.filter(p => p.type === type);
                        if (candidates.length > 0) {
                            // 既に選択されたポジションに最も近いものを選ぶ
                            let closest = null;
                            let minDist = Infinity;
                            
                            candidates.forEach(candidate => {
                                selectedPositions.forEach(selected => {
                                    const dist = Math.abs(candidate.string - selected.string) + 
                                                 Math.abs(candidate.fret - selected.fret);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        closest = candidate;
                                    }
                                });
                            });
                            
                            if (closest) {
                                selectedPositions.push(closest);
                                used.add(`${closest.string}-${closest.fret}`);
                            }
                        }
                    });
                    
                    if (selectedPositions.length >= 2) {
                        groups.push(selectedPositions);
                    }
                }
            });
            
            return groups;
        }
        
        // ルートを起点として、コードフォームに沿って並べ替え
        function sortByChordForm(group, toneTypes, tonePositions) {
            // ルートを探す（typeプロパティがある場合はそれを使用）
            const roots = group.filter(p => {
                if (p.type === 'root') return true;
                // typeプロパティがない場合は、tonePositionsで確認
                return tonePositions.root && tonePositions.root.some(r => r.string === p.string && r.fret === p.fret);
            });
            
            if (roots.length === 0) {
                // ルートがない場合は、最も低いフレットの位置を起点にする
                group.sort((a, b) => {
                    if (a.fret !== b.fret) return a.fret - b.fret;
                    return a.string - b.string;
                });
                return group;
            }
            
            // ルートを起点として、トーンタイプの順序で並べ替え
            const root = roots[0];
            const sorted = [root];
            const used = new Set([`${root.string}-${root.fret}`]);
            
            // トーンタイプの順序に従って追加（ルート以外）
            toneTypes.forEach(type => {
                if (type === 'root') return;
                
                const candidates = group.filter(p => {
                    const key = `${p.string}-${p.fret}`;
                    if (used.has(key)) return false;
                    return p.type === type;
                });
                
                if (candidates.length > 0) {
                    // 既に追加されたポジションに最も近いものを選ぶ
                    let closest = null;
                    let minDist = Infinity;
                    
                    candidates.forEach(candidate => {
                        sorted.forEach(selected => {
                            const dist = Math.abs(candidate.string - selected.string) + 
                                         Math.abs(candidate.fret - selected.fret);
                            if (dist < minDist) {
                                minDist = dist;
                                closest = candidate;
                            }
                        });
                    });
                    
                    if (closest) {
                        sorted.push(closest);
                        used.add(`${closest.string}-${closest.fret}`);
                    }
                }
            });
            
            return sorted;
        }
        
        // 角を丸くした囲みを描画（内側にマージン）
        function drawRoundedOutline(svg, positions) {
            if (positions.length < 2) return;
            
            const margin = 18; // コードトーンの円の半径 + マージン
            const cornerRadius = 8; // 角の丸み
            
            // 各位置の周りにマージンを追加した点を計算
            const expandedPoints = positions.map(pos => {
                // 隣接する点との関係を考慮してマージンを追加
                return {
                    x: pos.x,
                    y: pos.y,
                    margin: margin
                };
            });
            
            // パスを構築（角を丸く）
            let pathData = '';
            
            if (positions.length === 2) {
                // 2点の場合は線を描画
                const p1 = expandedPoints[0];
                const p2 = expandedPoints[1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // 各点の周りに円を描く
                pathData = `M ${p1.x + Math.cos(angle + Math.PI / 2) * margin},${p1.y + Math.sin(angle + Math.PI / 2) * margin} ` +
                          `A ${margin},${margin} 0 0 1 ${p1.x + Math.cos(angle - Math.PI / 2) * margin},${p1.y + Math.sin(angle - Math.PI / 2) * margin} ` +
                          `L ${p2.x + Math.cos(angle - Math.PI / 2) * margin},${p2.y + Math.sin(angle - Math.PI / 2) * margin} ` +
                          `A ${margin},${margin} 0 0 1 ${p2.x + Math.cos(angle + Math.PI / 2) * margin},${p2.y + Math.sin(angle + Math.PI / 2) * margin} Z`;
            } else {
                // 3点以上の場合は閉じたパスを描画
                const points = expandedPoints.map(p => ({ x: p.x, y: p.y }));
                
                // 各点の周りにマージンを追加した形状を作成
                pathData = buildRoundedPath(points, margin, cornerRadius);
            }
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('fill', 'rgba(255, 255, 255, 0.15)');
            path.setAttribute('stroke', 'rgba(255, 255, 255, 0.6)');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('stroke-linejoin', 'round');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-dasharray', '5,5');
            
            // コードトーンの下に配置
            svg.insertBefore(path, svg.firstChild);
        }
        
        // 角を丸くしたパスを構築
        function buildRoundedPath(points, margin, cornerRadius) {
            if (points.length < 3) return '';
            
            let path = '';
            const n = points.length;
            
            for (let i = 0; i < n; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % n];
                const p0 = points[(i - 1 + n) % n];
                
                // 各点から外側への方向を計算
                const angle1 = Math.atan2(p1.y - p0.y, p1.x - p0.x);
                const angle2 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const bisectAngle = (angle1 + angle2) / 2;
                
                // マージンを追加した位置を計算
                const offsetX = Math.cos(bisectAngle + Math.PI / 2) * margin;
                const offsetY = Math.sin(bisectAngle + Math.PI / 2) * margin;
                
                const x = p1.x + offsetX;
                const y = p1.y + offsetY;
                
                if (i === 0) {
                    path += `M ${x},${y} `;
                } else {
                    // 前の点から現在の点への線（角を丸く）
                    const prevP = points[(i - 1 + n) % n];
                    const prevAngle1 = Math.atan2(prevP.y - points[(i - 2 + n) % n].y, prevP.x - points[(i - 2 + n) % n].x);
                    const prevAngle2 = Math.atan2(p1.y - prevP.y, p1.x - prevP.x);
                    const prevBisect = (prevAngle1 + prevAngle2) / 2;
                    const prevX = prevP.x + Math.cos(prevBisect + Math.PI / 2) * margin;
                    const prevY = prevP.y + Math.sin(prevBisect + Math.PI / 2) * margin;
                    
                    // 角を丸くするための曲線
                    path += `L ${prevX},${prevY} Q ${p1.x + offsetX * 0.5},${p1.y + offsetY * 0.5} ${x},${y} `;
                }
            }
            
            path += 'Z';
            return path;
        }


        // 凸包（Convex Hull）を計算（Graham scan algorithm）
        function calculateConvexHull(points) {
            if (points.length < 3) return points;
            
            // 最も下（yが最大）で、その中で最も左（xが最小）の点を見つける
            let bottomPoint = points[0];
            for (let i = 1; i < points.length; i++) {
                if (points[i].y > bottomPoint.y || 
                    (points[i].y === bottomPoint.y && points[i].x < bottomPoint.x)) {
                    bottomPoint = points[i];
                }
            }
            
            // 各点の角度を計算してソート
            const sorted = points
                .filter(p => p !== bottomPoint)
                .map(p => ({
                    ...p,
                    angle: Math.atan2(p.y - bottomPoint.y, p.x - bottomPoint.x)
                }))
                .sort((a, b) => a.angle - b.angle);
            
            // スタックを使って凸包を構築
            const hull = [bottomPoint];
            for (let i = 0; i < sorted.length; i++) {
                while (hull.length >= 2) {
                    const p1 = hull[hull.length - 2];
                    const p2 = hull[hull.length - 1];
                    const p3 = sorted[i];
                    
                    // 右回りかどうかをチェック
                    const cross = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
                    if (cross <= 0) break;
                    hull.pop();
                }
                hull.push(sorted[i]);
            }
            
            return hull;
        }

        // 実際のギターのフレット位置を計算する関数
        // スケール長を基準に、各フレットの位置を計算（フェンダーストラトキャスター: 25.5インチ）
        function calculateRealisticFretPositions(startFret, endFret) {
            const fretPositions = {};
            // スケール長をピクセルに変換（基準として、0-24フレットの範囲を適切なサイズに）
            const baseScaleLengthPixels = 1000; // 基準となるスケール長（ピクセル）
            
            // 各フレットの位置を計算（0フレット = ナット位置 = 0）
            for (let fret = 0; fret <= endFret; fret++) {
                // fret_position(n) = scale_length * (1 - 1 / (2^(n/12)))
                const fretPosition = baseScaleLengthPixels * (1 - 1 / Math.pow(2, fret / 12));
                fretPositions[fret] = fretPosition;
            }
            
            // 表示範囲（startFretからendFret）に合わせて正規化
            const startPos = fretPositions[startFret] || 0;
            const endPos = fretPositions[endFret];
            const range = endPos - startPos;
            
            // 実際のフレット位置を、表示範囲に合わせて正規化（0からの相対位置）
            const normalizedPositions = {};
            for (let fret = startFret; fret <= endFret; fret++) {
                normalizedPositions[fret] = fretPositions[fret] - startPos;
            }
            
            return { positions: normalizedPositions, range };
        }

        // トグルスイッチから表示モードの値を取得
        function getDisplayMode() {
            const allModeToggle = document.getElementById('allModeToggle');
            const allModeLabel = document.getElementById('allModeToggleLabel');
            
            // 全ポジション表示が有効な場合（拡張コードがある場合のみ）
            if (allModeLabel && allModeLabel.style.display !== 'none' && allModeToggle.checked) {
                return 'all';
            }
            
            // セブンス表示トグルがONの場合
            const seventhModeToggle = document.getElementById('seventhModeToggle');
            if (seventhModeToggle && seventhModeToggle.checked) {
                return 'seventh';
            }
            
            // デフォルトはトライアドのみ
            return 'triad';
        }

        function generateFretboard() {
            const { key, chordType, name: chordName } = getCurrentChord();
            const startFret = parseInt(document.getElementById('startFret').value);
            const endFret = parseInt(document.getElementById('endFret').value);
            const displayMode = getDisplayMode();
            const realisticSpacing = document.getElementById('realisticFretSpacing').checked;
            const tones = getChordTones(key, chordType);
            console.log('generateFretboard:', { key, chordType, tones }); // デバッグ用
            
            if (!tones) {
                console.error('Failed to get chord tones for:', key, chordType);
                return;
            }
            
            const tuning = getCurrentTuning();
            const strings = tuning.strings;

            const container = document.getElementById('fretboard');
            container.innerHTML = '';

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', 'auto');
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            
            const fretCount = endFret - startFret + 1;
            const stringSpacing = 50; // 弦の間隔を大きく
            const baseFretSpacing = 60; // 基本フレット間の距離
            
            // 実在のギターのフレット間隔を使用するかどうか
            let fretPositions = {};
            let fretSpacing = baseFretSpacing;
            
            if (realisticSpacing) {
                const fretCalc = calculateRealisticFretPositions(startFret, endFret);
                // 実際の間隔を計算しつつ、表示幅を適切に調整
                const scaleFactor = (baseFretSpacing * (fretCount - 1)) / fretCalc.range;
                // オブジェクトの各フレット位置をスケール
                for (let fret = startFret; fret <= endFret; fret++) {
                    fretPositions[fret] = fretCalc.positions[fret] * scaleFactor;
                }
            } else {
                // 等間隔の場合
                for (let f = 0; f <= fretCount; f++) {
                    fretPositions[startFret + f] = f * baseFretSpacing;
                }
            }
            
            const titleY = 25; // コード名のY位置（上に移動）
            const fretNumberY = 45; // フレット番号のY位置（コード名との間隔を広げる）
            const topMargin = 70; // 上部マージン（指板の開始位置）
            const leftMargin = 120; // 左側マージン（弦名用のスペースを増やす）
            const rightMargin = 50;
            const bottomMargin = 50; // 下部マージン（ポジションマーク用のスペース）
            
            // 総幅を計算（実際のフレット位置を使用）- 終了フレットの位置まで
            const maxFretXPos = realisticSpacing ? fretPositions[endFret] : (fretCount - 1) * fretSpacing;
            const totalWidth = leftMargin + maxFretXPos + rightMargin;
            const totalHeight = topMargin + (strings.length - 1) * stringSpacing + bottomMargin;
            
            svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
            
            // フレット位置を取得するヘルパー関数
            const getFretX = (fretNum) => {
                if (fretPositions[fretNum] !== undefined) {
                    return leftMargin + fretPositions[fretNum];
                }
                // フォールバック（等間隔）
                return leftMargin + (fretNum - startFret) * fretSpacing;
            };
            
            // フレット間の中間位置を取得するヘルパー関数（押弦位置）
            const getFretMiddleX = (fretNum) => {
                if (fretNum === 0) {
                    return leftMargin - 30; // 開放弦は弦名表示領域
                }
                const currentX = getFretX(fretNum);
                const prevX = getFretX(fretNum - 1);
                return (prevX + currentX) / 2; // 前のフレットと現在のフレットの中間
            };

            // フレット線を描画
            for (let f = 0; f < fretCount; f++) {
                const fretNum = startFret + f;
                const x = getFretX(fretNum);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', topMargin);
                line.setAttribute('x2', x);
                line.setAttribute('y2', topMargin + (strings.length - 1) * stringSpacing);
                line.setAttribute('stroke', '#666');
                line.setAttribute('stroke-width', f === 0 ? '3' : '1');
                svg.appendChild(line);
            }
            // 終了フレットの境界線を描画
            const endFretX = getFretX(endFret);
            const endLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            endLine.setAttribute('x1', endFretX);
            endLine.setAttribute('y1', topMargin);
            endLine.setAttribute('x2', endFretX);
            endLine.setAttribute('y2', topMargin + (strings.length - 1) * stringSpacing);
            endLine.setAttribute('stroke', '#666');
            endLine.setAttribute('stroke-width', '1');
            svg.appendChild(endLine);

            // 弦を描画
            const endX = getFretX(endFret);
            for (let s = 0; s < strings.length; s++) {
                const y = topMargin + s * stringSpacing;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', leftMargin);
                line.setAttribute('y1', y);
                line.setAttribute('x2', endX);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#888');
                line.setAttribute('stroke-width', '2.5'); // 弦の太さを少し太く
                svg.appendChild(line);

                // 開放弦の音名（左側に十分なスペースを確保）
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', leftMargin - 30);
                text.setAttribute('y', y + 6);
                text.setAttribute('fill', '#e0e0e0');
                text.setAttribute('font-size', '16');
                text.setAttribute('text-anchor', 'middle');
                text.textContent = strings[s];
                svg.appendChild(text);
            }

            // フレット番号（上部に十分なスペースを確保）
            for (let f = 0; f < fretCount; f++) {
                const fretNum = startFret + f;
                const x = getFretX(fretNum);
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', fretNumberY);
                text.setAttribute('fill', '#888');
                text.setAttribute('font-size', '14');
                text.setAttribute('text-anchor', 'middle');
                text.textContent = fretNum === 0 ? '0' : fretNum;
                svg.appendChild(text);
            }
            // 終了フレットの番号を表示
            const endFretNumX = getFretX(endFret);
            const endFretText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            endFretText.setAttribute('x', endFretNumX);
            endFretText.setAttribute('y', fretNumberY);
            endFretText.setAttribute('fill', '#888');
            endFretText.setAttribute('font-size', '14');
            endFretText.setAttribute('text-anchor', 'middle');
            endFretText.textContent = endFret.toString();
            svg.appendChild(endFretText);
            
            // ポジションマークの不透明度をスライダーから取得（0-100の値を0-1に変換）
            const positionMarkOpacityValue = parseInt(document.getElementById('positionMarkOpacity').value) / 100;
            // ポジションマークの形状を取得
            const positionMarkShape = document.getElementById('positionMarkShape').value;
            // ポジションマークの色を取得
            const positionMarkColor = document.getElementById('positionMarkColor').value;
            
            // 形状に応じたポジションマークの配置を決定
            let positionMarks;
            let isDoubleMarkAt12;
            
            if (positionMarkShape === 'gibson') {
                // レスポールカスタム型：1, 3, 5, 7, 9, 12, 15, 17, 19, 21（24フレットモデルなら24も）
                // 1フレットにマークがある（13フレットには無い）
                // 12フレットは1つのマークのみ（フェンダーとは異なる）
                positionMarks = endFret >= 24 ? [1, 3, 5, 7, 9, 12, 15, 17, 19, 21, 24] : [1, 3, 5, 7, 9, 12, 15, 17, 19, 21];
                isDoubleMarkAt12 = false;
            } else if (positionMarkShape === 'lespaul') {
                // レスポールスタンダード型（台形）：3, 5, 7, 9, 12, 15, 17, 19, 21（24フレットモデルなら24も）
                // 1フレットにマークは無い（13フレットにも無い）
                // 12フレットは1つのマークのみ
                positionMarks = endFret >= 24 ? [3, 5, 7, 9, 12, 15, 17, 19, 21, 24] : [3, 5, 7, 9, 12, 15, 17, 19, 21];
                isDoubleMarkAt12 = false;
            } else {
                // フェンダー型その他：3, 5, 7, 9, 12, 15, 17, 19, 21, 24フレット
                // 12フレットと24フレットは2つのマーク
                positionMarks = [3, 5, 7, 9, 12, 15, 17, 19, 21, 24];
                isDoubleMarkAt12 = true;
            }
            
            // ポジションマークの配置位置：弦と弦の間の中央
            // 通常は3弦と4弦の間に配置
            const stringIndex1 = 2; // 3弦（0-indexedなので2）
            const stringIndex2 = 3; // 4弦（0-indexedなので3）
            const markYBetween = topMargin + (stringIndex1 * stringSpacing + stringIndex2 * stringSpacing) / 2;
            
            // 12フレットと24フレット用の2つのマークの位置（2弦、5弦にかかるぐらいに内側へ）
            // 1弦と2弦の間ではなく、2弦の位置に近い位置（2弦に少しかかる）
            const stringIndex1_double = 1; // 2弦
            const markY_double_1 = topMargin + stringIndex1_double * stringSpacing - 8; // 2弦の少し上（2弦にかかる）
            // 5弦と6弦の間ではなく、5弦の位置に近い位置（5弦に少しかかる）
            const stringIndex3_double = 4; // 5弦
            const markY_double_2 = topMargin + stringIndex3_double * stringSpacing + 8; // 5弦の少し下（5弦にかかる）
            
            // 形状に応じたサイズ
            let markSize;
            if (positionMarkShape === 'gibson' || positionMarkShape === 'lespaul') {
                markSize = 20; // ギブソン型（レスポールカスタム/スタンダード）は大きめ（基本サイズ）
            } else {
                markSize = 16; // フェンダー型その他
            }
            
            // ポジションマークを描画する関数
            const drawPositionMark = (x, y, svg, fretNum = null) => {
                let element;
                
                if (positionMarkShape === 'fender') {
                    // フェンダー型：丸
                    element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    element.setAttribute('cx', x);
                    element.setAttribute('cy', y);
                    element.setAttribute('r', markSize);
                } else if (positionMarkShape === 'gibson') {
                    // レスポールカスタム型：ブロック（角丸の長方形）
                    element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    
                    // 横幅：フレット間隔に合わせる（前のフレットと現在のフレットの間の距離の70%程度）
                    let width;
                    if (fretNum !== null && fretNum > 0) {
                        const currentX = getFretX(fretNum);
                        const prevX = getFretX(fretNum - 1);
                        const fretSpacingPx = Math.abs(currentX - prevX);
                        width = fretSpacingPx * 0.7; // フレット間隔の70%
                    } else {
                        // フォールバック（固定幅）
                        width = markSize * 3;
                    }
                    
                    // 縦幅：2弦/5弦より少し外側に来るサイズ
                    // 2弦から5弦までの距離 + マージン（上下に余裕を持たせる）
                    const string2Y = topMargin + 1 * stringSpacing;
                    const string5Y = topMargin + 4 * stringSpacing;
                    const baseHeight = string5Y - string2Y; // 2弦から5弦までの距離（3 * stringSpacing）
                    const height = baseHeight + (stringSpacing * 0.8); // 上下に余裕を持たせる（合計約3.8 * stringSpacing）
                    
                    element.setAttribute('x', x - width / 2);
                    element.setAttribute('y', y - height / 2);
                    element.setAttribute('width', width);
                    element.setAttribute('height', height);
                    element.setAttribute('rx', 4);
                    element.setAttribute('ry', 4);
                } else if (positionMarkShape === 'lespaul') {
                    // レスポールスタンダード型：台形（左側が小さく、右側が大きい、横方向に広がる）
                    element = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    
                    // 縦幅：2弦/5弦より少し外側に来るサイズ（回転後は縦方向の高さになる）
                    const string2Y = topMargin + 1 * stringSpacing;
                    const string5Y = topMargin + 4 * stringSpacing;
                    const baseHeight = string5Y - string2Y;
                    const verticalHeight = baseHeight + (stringSpacing * 0.8); // 回転後の縦方向の高さの基準
                    // 2弦/5弦から少しはみ出す程度に大きくする
                    const expandedVerticalHeight = verticalHeight * 1.3; // さらに30%大きく
                    
                    // 横幅：フレット間隔に合わせる（前のフレットと現在のフレットの間の距離に基づく）
                    // 横方向の台形：左側（1フレット側）が大きく、右側（ボディ側）が小さい
                    // まず縦方向の台形を作成し、90度回転させる
                    let topWidth;    // 上辺の幅（回転後は右側、小さい）
                    let bottomWidth; // 下辺の幅（回転後は左側、大きい）
                    if (fretNum !== null && fretNum > 0) {
                        const currentX = getFretX(fretNum);
                        const prevX = getFretX(fretNum - 1);
                        const fretSpacingPx = Math.abs(currentX - prevX);
                        bottomWidth = fretSpacingPx * 0.7;  // 下辺はフレット間隔の70%（回転後は左側、大きい）
                        topWidth = bottomWidth * 0.45;      // 上辺は下辺の45%（回転後は右側、小さい）
                    } else {
                        // フォールバック（固定幅）
                        bottomWidth = markSize * 3;
                        topWidth = bottomWidth * 0.45;
                    }
                    
                    // 回転前の台形の寸法を設定
                    // 回転前の「高さ」は、回転後の横方向の幅になる → フレット間隔に基づく値（bottomWidth）を使う
                    // 回転前の「幅」は、回転後の縦方向の高さになる → topWidth/bottomWidthを使う（台形の上辺と下辺）
                    const horizontalWidth = bottomWidth; // 回転後の横方向の幅（回転前の高さ、フレット間隔に基づく）
                    const topY = y - horizontalWidth / 2;    // 上辺（y座標、回転前の高さ）
                    const bottomY = y + horizontalWidth / 2; // 下辺（y座標）
                    
                    // 回転前の台形の幅（回転後の縦方向の高さになる）
                    // 回転後の縦方向の高さは2弦/5弦から少しはみ出す程度（expandedVerticalHeight）にする
                    // 台形の上辺と下辺の幅の比率を維持しつつ、全体の高さをexpandedVerticalHeightにする
                    const topTrapezoidWidth = expandedVerticalHeight * 0.45;  // 上辺の幅（小さい、比率45%）
                    const bottomTrapezoidWidth = expandedVerticalHeight * 0.7; // 下辺の幅（大きい、比率70%）
                    
                    const topLeftX = x - topTrapezoidWidth / 2;   // 左上（上辺の左端、小さい）
                    const topRightX = x + topTrapezoidWidth / 2;  // 右上（上辺の右端、小さい）
                    
                    const bottomLeftX = x - bottomTrapezoidWidth / 2;   // 左下（下辺の左端、大きい）
                    const bottomRightX = x + bottomTrapezoidWidth / 2;  // 右下（下辺の右端、大きい）
                    
                    // 左上→右上→右下→左下の順（時計回り）
                    // 上辺が小さく、下辺が大きい縦方向の台形
                    const points = [
                        `${topLeftX},${topY}`,      // 左上（上辺の左端、小さい）
                        `${topRightX},${topY}`,     // 右上（上辺の右端、小さい）
                        `${bottomRightX},${bottomY}`, // 右下（下辺の右端、大きい）
                        `${bottomLeftX},${bottomY}`   // 左下（下辺の左端、大きい）
                    ].join(' ');
                    element.setAttribute('points', points);
                    
                    // 90度回転させて横方向の台形にする（左側が大きく、右側が小さい）
                    element.setAttribute('transform', `rotate(90 ${x} ${y})`);
                } else if (positionMarkShape === 'diamond') {
                    // ダイヤモンド型
                    element = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const size = markSize * 1.5;
                    const points = `${x},${y - size} ${x + size},${y} ${x},${y + size} ${x - size},${y}`;
                    element.setAttribute('points', points);
                } else if (positionMarkShape === 'rectangle') {
                    // 長方形型
                    element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    const width = markSize * 2;
                    const height = markSize * 1.2;
                    element.setAttribute('x', x - width / 2);
                    element.setAttribute('y', y - height / 2);
                    element.setAttribute('width', width);
                    element.setAttribute('height', height);
                }
                
                if (element) {
                    element.setAttribute('fill', positionMarkColor);
                    element.setAttribute('opacity', positionMarkOpacityValue);
                    svg.appendChild(element);
                }
            };
            
            positionMarks.forEach(fretNum => {
                if (fretNum >= startFret && fretNum <= endFret) {
                    // フレットとフレットの中間位置（実際の押弦位置）に配置
                    const markX = getFretMiddleX(fretNum);
                    
                    // 12フレットと24フレットの処理（形状に応じて異なる）
                    if (isDoubleMarkAt12 && (fretNum === 12 || fretNum === 24)) {
                        // フェンダー型：2つのマーク（上下に配置）
                        drawPositionMark(markX, markY_double_1, svg, fretNum);
                        drawPositionMark(markX, markY_double_2, svg, fretNum);
                    } else {
                        // ギブソン型など：1つのマーク（中央に配置）
                        drawPositionMark(markX, markYBetween, svg, fretNum);
                    }
                }
            });

            // コードトーンの位置を先に収集（重なり判定用）
            const chordToneMap = new Map(); // key: "string-fret", value: toneType
            for (let s = 0; s < strings.length; s++) {
                for (let f = 0; f < fretCount; f++) {
                    const fretNum = startFret + f;
                    const note = getNoteAtPosition(s, fretNum);
                    const toneType = getToneType(note, tones);
                    
                    if (toneType) {
                        // 表示モードのチェック
                        const isSusTone = ['sus2', 'sus4'].includes(toneType);
                        const isDimAugTone = ['dim5', 'aug5'].includes(toneType);
                        const isSeventhTone = toneType === 'seventh';
                        const isOtherExtendedTone = ['ninth', 'sixth'].includes(toneType);
                        
                        let shouldDisplay = false;
                        
                        if (displayMode === 'triad') {
                            if (isOtherExtendedTone || isSeventhTone) {
                                continue;
                            }
                            shouldDisplay = true;
                        } else if (displayMode === 'seventh') {
                            if (isOtherExtendedTone) {
                                continue;
                            }
                            shouldDisplay = true;
                        } else if (displayMode === 'all') {
                            shouldDisplay = true;
                        }
                        
                        if (shouldDisplay) {
                            const key = `${s}-${fretNum}`;
                            chordToneMap.set(key, toneType);
                        }
                    }
                }
            }
            
            // スケールトーンを描画（コードトーンの後ろのレイヤー）
            const scaleKey = document.getElementById('scaleKey')?.value || 'C';
            const scaleType = document.getElementById('scaleType')?.value || 'none';
            const scaleNotes = getScaleNotes(scaleKey, scaleType);
            
            // スケールトーンを描画
            if (scaleNotes.length > 0) {
                for (let s = 0; s < strings.length; s++) {
                    for (let f = 0; f < fretCount; f++) {
                        const fretNum = startFret + f;
                        const note = getNoteAtPosition(s, fretNum);
                        
                        // スケールに含まれるかチェック（異名同音も考慮）
                        const isScaleNote = scaleNotes.some(scaleNote => 
                            note === scaleNote || isEnharmonicEquivalent(note, scaleNote)
                        );
                        
                        if (isScaleNote) {
                            const x = getFretMiddleX(fretNum);
                            const y = topMargin + s * stringSpacing;
                            const key = `${s}-${fretNum}`;
                            const chordToneType = chordToneMap.get(key);
                            
                            // コードトーンと重なっていない場合は白丸で表示
                            if (!chordToneType) {
                                // 重なっていない場合は白丸で表示
                                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                circle.setAttribute('cx', x);
                                circle.setAttribute('cy', y);
                                circle.setAttribute('r', '12');
                                circle.setAttribute('fill', '#fff');
                                circle.setAttribute('stroke', '#fff');
                                circle.setAttribute('stroke-width', '1');
                                circle.setAttribute('opacity', '0.8');
                                svg.appendChild(circle);
                            }
                        }
                    }
                }
            }

            // コードトーンの位置を収集（囲み用）
            const tonePositions = {
                root: [],
                third: [],
                fifth: [],
                seventh: [],
                dim5: [],
                aug5: [],
                sus2: [],
                sus4: [],
                ninth: [],
                sixth: []
            };

            // コードトーンを描画
            for (let s = 0; s < strings.length; s++) {
                for (let f = 0; f < fretCount; f++) {
                    const fretNum = startFret + f;
                    const note = getNoteAtPosition(s, fretNum);
                    const toneType = getToneType(note, tones);

                    if (toneType) {
                        // 表示モードのチェック
                        // サスペンドコード（sus2, sus4）はトライアドの一部として扱う
                        // ディミニッシュ（dim5）とオーギュメント（aug5）もトライアドの一部として扱う
                        const isSusTone = ['sus2', 'sus4'].includes(toneType);
                        const isDimAugTone = ['dim5', 'aug5'].includes(toneType);
                        const isSeventhTone = toneType === 'seventh';
                        const isOtherExtendedTone = ['ninth', 'sixth'].includes(toneType);
                        
                        let shouldDisplay = false;
                        
                        // トライアドモード: ルート、3rd、5th、sus2/sus4、dim5/aug5を表示
                        if (displayMode === 'triad') {
                            if (isOtherExtendedTone || isSeventhTone) {
                                continue; // ninth、sixth、7thはスキップ
                            }
                            shouldDisplay = true; // dim5、aug5、sus2、sus4は表示（トライアドの一部）
                        }
                        // セブンス含むモード: ルート、3rd、5th、7th、sus2/sus4、dim5/aug5を表示
                        else if (displayMode === 'seventh') {
                            if (isOtherExtendedTone) {
                                continue; // ninth、sixthはスキップ
                            }
                            shouldDisplay = true; // 7thは表示（コードに7thが定義されていなくても、ルートに対して7thが存在すれば表示）
                        }
                        // 全ポジション: すべて表示
                        else if (displayMode === 'all') {
                            shouldDisplay = true;
                        }
                        
                        if (shouldDisplay) {
                            // フレットとフレットの中間（実際の押弦位置）に配置
                            const x = getFretMiddleX(fretNum);
                            const y = topMargin + s * stringSpacing;

                            // 位置を記録（囲み用）
                            if (tonePositions[toneType]) {
                                tonePositions[toneType].push({ x, y, string: s, fret: fretNum });
                            }

                            // スケールトーンと重なっているかチェック
                            const key = `${s}-${fretNum}`;
                            const isScaleNote = scaleNotes.length > 0 && scaleNotes.some(scaleNote => 
                                note === scaleNote || isEnharmonicEquivalent(note, scaleNote)
                            );
                            
                            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            circle.setAttribute('cx', x);
                            circle.setAttribute('cy', y);
                            circle.setAttribute('r', '14'); // コードトーンの円を少し大きく
                            
                            const colors = {
                                'root': '#ff4444',
                                'third': '#4444ff',
                                'fifth': '#44ff44',
                                'seventh': '#ffff44',
                                'dim5': '#ff44ff',
                                'aug5': '#ff8844',
                                'sus2': '#44ffff',
                                'sus4': '#ffaa44',
                                'ninth': '#aa44ff',
                                'sixth': '#44ffaa'
                            };
                            
                            // スケールトーンと重なっている場合の処理
                            if (isScaleNote) {
                                if (toneType === 'root') {
                                    // トライアドのルートと重なった場合：白の塗りつぶし、赤の枠
                                    circle.setAttribute('fill', '#fff');
                                    circle.setAttribute('stroke', '#ff4444');
                                    circle.setAttribute('stroke-width', '4');
                                } else {
                                    // トライアドのルート以外と重なった場合：通常の色、太い枠
                                    circle.setAttribute('fill', colors[toneType]);
                                    circle.setAttribute('stroke', '#fff');
                                    circle.setAttribute('stroke-width', '4');
                                }
                            } else {
                                // 重なっていない場合：通常の表示
                                circle.setAttribute('fill', colors[toneType]);
                                circle.setAttribute('stroke', '#fff');
                                circle.setAttribute('stroke-width', '2');
                            }
                            
                            svg.appendChild(circle);

                            // 音名を表示
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', x);
                            text.setAttribute('y', y + 5);
                            
                            // スケールトーンと重なっている場合、ルートの場合は文字色を黒に
                            if (isScaleNote && toneType === 'root') {
                                text.setAttribute('fill', '#000');
                            } else {
                                text.setAttribute('fill', '#000');
                            }
                            
                            text.setAttribute('font-size', '11');
                            text.setAttribute('font-weight', 'bold');
                            text.setAttribute('text-anchor', 'middle');
                            text.textContent = note;
                            svg.appendChild(text);
                        }
                    }
                }
            }

            // コードトーンを囲む機能（一旦無効化）
            // const showOutline = document.getElementById('showOutline').checked;
            // if (showOutline) {
            //     drawToneOutlines(svg, tonePositions, displayMode, tones);
            // }

            // コード名を表示
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', totalWidth / 2);
            title.setAttribute('y', titleY);
            title.setAttribute('fill', '#e0e0e0');
            title.setAttribute('font-size', '22');
            title.setAttribute('font-weight', 'bold');
            title.setAttribute('text-anchor', 'middle');
            title.textContent = `${chordName} - ${Object.values(tones).join(', ')}`;
            svg.appendChild(title);

            container.appendChild(svg);
            
            // 表示されているトーンタイプを収集して下部のインターバル表示を更新
            const legendModeToggle = document.getElementById('legendModeToggle');
            const legendMode = legendModeToggle && legendModeToggle.checked ? 'displayedOnly' : 'all';
            updateIntervalDisplay(displayMode, tones, tonePositions, legendMode);
        }
        
        // 下部のインターバル表示を更新
        function updateIntervalDisplay(displayMode, tones, tonePositions, legendMode) {
            // 実際に指板上に表示されているトーンタイプを取得（tonePositionsから）
            // これにより、指板の表示と凡例が常に一致する
            const displayedTypes = Object.keys(tonePositions).filter(type => 
                tonePositions[type] && tonePositions[type].length > 0
            );
            
            // 凡例表示モードに応じて処理
            const legendItems = document.querySelectorAll('.legend-item');
            
            // まず全ての項目をリセット（表示状態とスタイルを初期化）
            legendItems.forEach(item => {
                const dot = item.querySelector('.legend-dot');
                const span = item.querySelector('span');
                if (!dot || !span) return;
                
                // displayを常にリセット（コード切り替え時に前の状態が残らないように）
                item.style.display = 'flex';
                
                // スタイルもリセット
                dot.style.opacity = '';
                span.style.opacity = '';
                span.style.fontWeight = '';
            });
            
            if (legendMode === 'displayedOnly') {
                // 表示されているもののみを表示（非表示のものは完全に非表示）
                legendItems.forEach(item => {
                    const dot = item.querySelector('.legend-dot');
                    const span = item.querySelector('span');
                    if (!dot || !span) return;
                    
                    const toneType = getToneTypeFromLegend(span.textContent);
                    if (toneType && displayedTypes.includes(toneType)) {
                        // 表示されている場合は表示
                        item.style.display = 'flex';
                    } else {
                        // 表示されていない場合は非表示
                        item.style.display = 'none';
                    }
                });
            } else {
                // 全て表示（活性/非活性で区別）
                legendItems.forEach(item => {
                    const dot = item.querySelector('.legend-dot');
                    const span = item.querySelector('span');
                    if (!dot || !span) return;
                    
                    const toneType = getToneTypeFromLegend(span.textContent);
                    if (toneType && displayedTypes.includes(toneType)) {
                        // 表示されている場合は活性化（色を濃く、不透明度を上げる）
                        dot.style.opacity = '1';
                        span.style.opacity = '1';
                        span.style.fontWeight = 'bold';
                    } else {
                        // 表示されていない場合はグレーアウト
                        dot.style.opacity = '0.3';
                        span.style.opacity = '0.3';
                        span.style.fontWeight = 'normal';
                    }
                });
            }
        }
        
        // レジェンドのテキストからトーンタイプを取得
        function getToneTypeFromLegend(text) {
            const mapping = {
                'ルート': 'root',
                '3rd': 'third',
                '5th': 'fifth',
                '7th': 'seventh',
                '♭5th': 'dim5',
                '#5th': 'aug5',
                '2nd': 'sus2',
                '4th': 'sus4',
                '9th': 'ninth',
                '6th': 'sixth'
            };
            return mapping[text] || null;
        }

        function downloadSVG() {
            const svg = document.querySelector('#fretboard svg');
            if (!svg) return;
            
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `fretboard-${getCurrentChord().name}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadPNG() {
            const svg = document.querySelector('#fretboard svg');
            if (!svg) return;

            const svgData = new XMLSerializer().serializeToString(svg);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = function() {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `fretboard-${getCurrentChord().name}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            };
            
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }

        // コード選択時に表示モードオプションを更新
        function updateDisplayModeOptions() {
            const { key, chordType } = getCurrentChord();
            const tones = getChordTones(key, chordType);
            const allModeLabel = document.getElementById('allModeToggleLabel');
            const allModeToggle = document.getElementById('allModeToggle');
            
            if (!tones) {
                if (allModeLabel) allModeLabel.style.display = 'none';
                return;
            }
            
            // 拡張トーン（ninth、sixth）がある場合のみ「全ポジション表示」トグルを表示
            const hasExtendedTones = (tones.ninth !== undefined) || (tones.sixth !== undefined);
            
            if (hasExtendedTones) {
                if (allModeLabel) allModeLabel.style.display = 'flex';
            } else {
                if (allModeLabel) allModeLabel.style.display = 'none';
                // 全ポジション表示がONの場合はOFFに戻す
                if (allModeToggle && allModeToggle.checked) {
                    allModeToggle.checked = false;
                }
            }
        }
        
        // キーとコード種別選択のイベントリスナーを設定
        document.getElementById('keySelect').addEventListener('change', function() {
            updateDisplayModeOptions();
            generateFretboard();
        });
        document.getElementById('chordTypeSelect').addEventListener('change', function() {
            updateDisplayModeOptions();
            generateFretboard();
        });
        
        // フレット範囲の変更時に自動生成
        document.getElementById('startFret').addEventListener('change', generateFretboard);
        document.getElementById('startFret').addEventListener('input', generateFretboard);
        document.getElementById('endFret').addEventListener('change', generateFretboard);
        document.getElementById('endFret').addEventListener('input', generateFretboard);
        
        // 表示モードの変更時に自動生成（トグルスイッチ）
        document.getElementById('seventhModeToggle').addEventListener('change', generateFretboard);
        const allModeToggle = document.getElementById('allModeToggle');
        if (allModeToggle) {
            allModeToggle.addEventListener('change', function() {
                // 全ポジション表示がONの場合、セブンス表示を自動でOFFにしない（両方ONでも可）
                generateFretboard();
            });
        }
        
        // チューニング変更時に自動生成
        document.getElementById('tuningSelect').addEventListener('change', generateFretboard);
        
        // フレット間隔オプション変更時に自動生成
        document.getElementById('realisticFretSpacing').addEventListener('change', generateFretboard);
        
        // 凡例表示モード変更時に自動生成（トグルスイッチ）
        const legendModeToggle = document.getElementById('legendModeToggle');
        if (legendModeToggle) {
            legendModeToggle.addEventListener('change', generateFretboard);
        }
        
        // ポジションマーク形状変更時に自動生成
        document.getElementById('positionMarkShape').addEventListener('change', generateFretboard);
        
        // ポジションマーク色変更時に自動生成
        document.getElementById('positionMarkColor').addEventListener('change', generateFretboard);
        
        // ポジションマーク濃度スライダーのイベントリスナー
        const positionMarkOpacitySlider = document.getElementById('positionMarkOpacity');
        const positionMarkOpacityValueDisplay = document.getElementById('positionMarkOpacityValue');
        
        // スライダーの値を表示
        positionMarkOpacitySlider.addEventListener('input', function() {
            positionMarkOpacityValueDisplay.textContent = this.value + '%';
            generateFretboard(); // スライダー変更時に指板を再生成
        });
        
        // スケールキーとスケールタイプの変更時に自動生成
        document.getElementById('scaleKey').addEventListener('change', generateFretboard);
        document.getElementById('scaleType').addEventListener('change', generateFretboard);
        
        // 初期化時に実行
        updateDisplayModeOptions();
        
        // 初期表示
        generateFretboard();
        
        // テストコード: 凡例と指板の表示の一致を確認
        function testLegendConsistency() {
            const tests = [];
            
            // 代表的なキー+コード種別と表示モードの組み合わせでテスト
            const testCases = [
                { key: 'A', chordType: 'major', displayMode: 'triad' },
                { key: 'A', chordType: 'major', displayMode: 'seventh' },
                { key: 'A', chordType: '7', displayMode: 'seventh' },
                { key: 'A', chordType: 'minor', displayMode: 'triad' },
                { key: 'A', chordType: 'sus2', displayMode: 'triad' },
                { key: 'A', chordType: 'dim', displayMode: 'triad' },
                { key: 'A', chordType: 'aug', displayMode: 'triad' },
                { key: 'A', chordType: '9', displayMode: 'all' },
                { key: 'C', chordType: 'major', displayMode: 'triad' },
                { key: 'F#', chordType: 'm7', displayMode: 'seventh' }
            ];
            
            for (const testCase of testCases) {
                const { key, chordType, displayMode } = testCase;
                const tones = getChordTones(key, chordType);
                const chordName = key + (chordType === 'major' ? '' : chordType);
                if (!tones) continue;
                
                // 実際の表示ロジックに基づいて、どのトーンタイプが表示されるかを判断
                const mockTonePositions = {};
                
                // コードに定義されているトーンタイプを確認
                const toneTypeMap = {
                    'root': 'root',
                    'third': 'third',
                    'fifth': 'fifth',
                    'seventh': 'seventh',
                    'dim5': 'dim5',
                    'aug5': 'aug5',
                    'sus2': 'sus2',
                    'sus4': 'sus4',
                    'ninth': 'ninth',
                    'sixth': 'sixth'
                };
                
                for (const [toneKey, mappedType] of Object.entries(toneTypeMap)) {
                    if (tones[toneKey]) {
                        let shouldBeDisplayed = false;
                        
                        if (displayMode === 'triad') {
                            shouldBeDisplayed = ['root', 'third', 'fifth', 'sus2', 'sus4', 'dim5', 'aug5'].includes(mappedType);
                        } else if (displayMode === 'seventh') {
                            shouldBeDisplayed = ['root', 'third', 'fifth', 'seventh', 'sus2', 'sus4', 'dim5', 'aug5'].includes(mappedType);
                        } else {
                            shouldBeDisplayed = true;
                        }
                        
                        if (shouldBeDisplayed) {
                            mockTonePositions[mappedType] = [{x: 0, y: 0}]; // ダミーデータ
                        }
                    }
                }
                
                // updateIntervalDisplayの動作をテスト
                const displayedTypes = Object.keys(mockTonePositions).filter(type => 
                    mockTonePositions[type] && mockTonePositions[type].length > 0
                );
                
                tests.push({
                    chord: chordName,
                    displayMode,
                    expectedTypes: Object.keys(mockTonePositions),
                    actualTypes: displayedTypes,
                    pass: JSON.stringify(displayedTypes.sort()) === JSON.stringify(Object.keys(mockTonePositions).sort())
                });
            }
            
            // テスト結果をコンソールに出力
            if (typeof console !== 'undefined' && console.log) {
                const passed = tests.filter(t => t.pass).length;
                const failed = tests.filter(t => !t.pass).length;
                console.log(`凡例一貫性テスト: ${passed} passed, ${failed} failed (total: ${tests.length})`);
                if (failed > 0) {
                    console.warn('失敗したテスト:', tests.filter(t => !t.pass));
                }
            }
            
            return tests;
        }
        
        // 開発モードの場合のみテストを実行（URLパラメータで制御: ?test=true）
        if (typeof URLSearchParams !== 'undefined' && new URLSearchParams(window.location.search).get('test') === 'true') {
            // ページロード後にテストを実行
            setTimeout(() => {
                testLegendConsistency();
            }, 1000);
        }
    </script>
</body>
</html>

