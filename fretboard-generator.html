<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>指板図ジェネレーター</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        .container {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        select, input, button {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #333;
            color: #e0e0e0;
            font-size: 14px;
        }
        button {
            cursor: pointer;
            background-color: #4a9eff;
            border: none;
            color: white;
        }
        button:hover {
            background-color: #3a8eef;
        }
        #fretboard {
            background-color: #1a1a1a;
            border: 2px solid #444;
            border-radius: 4px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }
        #fretboard svg {
            max-width: 100%;
            height: auto;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #666;
        }
        .root { background-color: #ff4444; }
        .third { background-color: #4444ff; }
        .fifth { background-color: #44ff44; }
        .seventh { background-color: #ffff44; }
        .dim5 { background-color: #ff44ff; }
        .aug5 { background-color: #ff8844; }
        .sus2 { background-color: #44ffff; }
        .sus4 { background-color: #ffaa44; }
        .ninth { background-color: #aa44ff; }
        .sixth { background-color: #44ffaa; }
        
        /* トグルスイッチのスタイル */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #4a9eff;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        .toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>指板図ジェネレーター</h1>
        <div class="controls">
            <label>
                コード:
                <select id="chordSelect">
                    <optgroup label="メジャー/マイナー">
                        <option value="A">A (A, C#, E)</option>
                        <option value="Am">Am (A, C, E)</option>
                        <option value="A7">A7 (A, C#, E, G)</option>
                        <option value="D">D (D, F#, A)</option>
                        <option value="Dm">Dm (D, F, A)</option>
                        <option value="D7">D7 (D, F#, A, C)</option>
                        <option value="E">E (E, G#, B)</option>
                        <option value="Em">Em (E, G, B)</option>
                        <option value="E7">E7 (E, G#, B, D)</option>
                        <option value="G">G (G, B, D)</option>
                        <option value="Gm">Gm (G, Bb, D)</option>
                        <option value="C">C (C, E, G)</option>
                    </optgroup>
                    <optgroup label="ディミニッシュ">
                        <option value="Adim">Adim (A, C, Eb)</option>
                        <option value="Adim7">Adim7 (A, C, Eb, Gb)</option>
                        <option value="Ddim">Ddim (D, F, Ab)</option>
                        <option value="Ddim7">Ddim7 (D, F, Ab, B)</option>
                        <option value="Edim">Edim (E, G, Bb)</option>
                        <option value="Edim7">Edim7 (E, G, Bb, Db)</option>
                    </optgroup>
                    <optgroup label="オーグメント">
                        <option value="Aaug">Aaug (A, C#, F)</option>
                        <option value="Daug">Daug (D, F#, A#)</option>
                        <option value="Eaug">Eaug (E, G#, C)</option>
                    </optgroup>
                    <optgroup label="サスペンド">
                        <option value="Asus2">Asus2 (A, B, E)</option>
                        <option value="Asus4">Asus4 (A, D, E)</option>
                        <option value="Dsus2">Dsus2 (D, E, A)</option>
                        <option value="Dsus4">Dsus4 (D, G, A)</option>
                        <option value="Esus2">Esus2 (E, F#, B)</option>
                        <option value="Esus4">Esus4 (E, A, B)</option>
                    </optgroup>
                    <optgroup label="拡張コード">
                        <option value="Aadd9">Aadd9 (A, C#, E, B)</option>
                        <option value="A9">A9 (A, C#, E, G, B)</option>
                        <option value="Am7">Am7 (A, C, E, G)</option>
                        <option value="Amaj7">Amaj7 (A, C#, E, G#)</option>
                        <option value="A6">A6 (A, C#, E, F#)</option>
                    </optgroup>
                </select>
            </label>
            <label>
                開始フレット:
                <input type="number" id="startFret" value="0" min="0" max="12">
            </label>
            <label>
                終了フレット:
                <input type="number" id="endFret" value="12" min="0" max="24">
            </label>
            <label class="toggle-label">
                セブンス表示:
                <label class="toggle-switch">
                    <input type="checkbox" id="seventhModeToggle">
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <label id="allModeToggleLabel" style="display: none;">
                全ポジション表示:
                <label class="toggle-switch">
                    <input type="checkbox" id="allModeToggle">
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <label>
                チューニング:
                <select id="tuningSelect">
                    <option value="standard" selected>標準チューニング (E A D G B E)</option>
                    <option value="halfStepDown">半音下げ (Eb Ab Db Gb Bb Eb)</option>
                </select>
            </label>
            <label class="toggle-label">
                実フレット間隔:
                <label class="toggle-switch">
                    <input type="checkbox" id="realisticFretSpacing" checked>
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <label class="toggle-label">
                凡例（表示中のみ）:
                <label class="toggle-switch">
                    <input type="checkbox" id="legendModeToggle">
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <label>
                ポジションマーク濃度:
                <input type="range" id="positionMarkOpacity" min="0" max="100" value="20" style="width: 100px;">
                <span id="positionMarkOpacityValue">20%</span>
            </label>
            <button onclick="downloadSVG()">SVGダウンロード</button>
            <button onclick="downloadPNG()">PNGダウンロード</button>
        </div>
    </div>

    <div class="container">
        <div id="fretboard"></div>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-dot root"></div>
                <span>ルート</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot third"></div>
                <span>3rd</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot fifth"></div>
                <span>5th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot seventh"></div>
                <span>7th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot dim5"></div>
                <span>♭5th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot aug5"></div>
                <span>#5th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot sus2"></div>
                <span>2nd</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot sus4"></div>
                <span>4th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot ninth"></div>
                <span>9th</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot sixth"></div>
                <span>6th</span>
            </div>
        </div>
    </div>

    <script>
        // チューニングの定義
        const tunings = {
            standard: {
                strings: ['E', 'B', 'G', 'D', 'A', 'E'], // 1弦(高音E) → 6弦(低音E)
                stringNotes: [4, 11, 7, 2, 9, 4] // MIDI note numbers (1弦→6弦の順)
            },
            halfStepDown: {
                strings: ['Eb', 'Bb', 'Gb', 'Db', 'Ab', 'Eb'], // 1弦(高音Eb) → 6弦(低音Eb)
                stringNotes: [3, 10, 6, 1, 8, 3] // MIDI note numbers (1弦→6弦の順)
            }
        };
        
        // 現在のチューニングを取得する関数
        function getCurrentTuning() {
            const tuningType = document.getElementById('tuningSelect')?.value || 'standard';
            return tunings[tuningType];
        }

        // コードトーンの定義
        const chordTones = {
            // メジャー/マイナー
            'A': { root: 'A', third: 'C#', fifth: 'E' },
            'Am': { root: 'A', third: 'C', fifth: 'E' },
            'A7': { root: 'A', third: 'C#', fifth: 'E', seventh: 'G' },
            'Am7': { root: 'A', third: 'C', fifth: 'E', seventh: 'G' },
            'Amaj7': { root: 'A', third: 'C#', fifth: 'E', seventh: 'G#' },
            'D': { root: 'D', third: 'F#', fifth: 'A' },
            'Dm': { root: 'D', third: 'F', fifth: 'A' },
            'D7': { root: 'D', third: 'F#', fifth: 'A', seventh: 'C' },
            'E': { root: 'E', third: 'G#', fifth: 'B' },
            'Em': { root: 'E', third: 'G', fifth: 'B' },
            'E7': { root: 'E', third: 'G#', fifth: 'B', seventh: 'D' },
            'G': { root: 'G', third: 'B', fifth: 'D' },
            'Gm': { root: 'G', third: 'Bb', fifth: 'D' },
            'C': { root: 'C', third: 'E', fifth: 'G' },
            // ディミニッシュ
            'Adim': { root: 'A', third: 'C', dim5: 'Eb' },
            'Adim7': { root: 'A', third: 'C', dim5: 'Eb', sixth: 'Gb' },
            'Ddim': { root: 'D', third: 'F', dim5: 'Ab' },
            'Ddim7': { root: 'D', third: 'F', dim5: 'Ab', sixth: 'B' },
            'Edim': { root: 'E', third: 'G', dim5: 'Bb' },
            'Edim7': { root: 'E', third: 'G', dim5: 'Bb', sixth: 'Db' },
            // オーグメント
            'Aaug': { root: 'A', third: 'C#', aug5: 'F' },
            'Daug': { root: 'D', third: 'F#', aug5: 'A#' },
            'Eaug': { root: 'E', third: 'G#', aug5: 'C' },
            // サスペンド
            'Asus2': { root: 'A', sus2: 'B', fifth: 'E' },
            'Asus4': { root: 'A', sus4: 'D', fifth: 'E' },
            'Dsus2': { root: 'D', sus2: 'E', fifth: 'A' },
            'Dsus4': { root: 'D', sus4: 'G', fifth: 'A' },
            'Esus2': { root: 'E', sus2: 'F#', fifth: 'B' },
            'Esus4': { root: 'E', sus4: 'A', fifth: 'B' },
            // 拡張コード
            'Aadd9': { root: 'A', third: 'C#', fifth: 'E', ninth: 'B' },
            'A9': { root: 'A', third: 'C#', fifth: 'E', seventh: 'G', ninth: 'B' },
            'A6': { root: 'A', third: 'C#', fifth: 'E', sixth: 'F#' }
        };

        // 音名を半音数に変換
        const noteToSemitone = {
            'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
            'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
            'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
        };
        
        // 異名同音のマッピング（Eb = D#, Gb = F#など）
        const enharmonicMap = {
            'Eb': 'D#', 'D#': 'Eb',
            'Gb': 'F#', 'F#': 'Gb',
            'Ab': 'G#', 'G#': 'Ab',
            'Bb': 'A#', 'A#': 'Bb',
            'Db': 'C#', 'C#': 'Db'
        };

        function getNoteAtPosition(stringIndex, fret) {
            const tuning = getCurrentTuning();
            const openNote = tuning.stringNotes[stringIndex];
            const semitone = (openNote + fret) % 12;
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            return noteNames[semitone];
        }
        
        // 異名同音のマッピング（Eb = D#, Gb = F#など）
        function isEnharmonicEquivalent(note1, note2) {
            if (!note1 || !note2) return false; // nullやundefinedの場合はfalse
            if (note1 === note2) return true;
            const enharmonicPairs = {
                'Eb': 'D#', 'D#': 'Eb',
                'Gb': 'F#', 'F#': 'Gb',
                'Ab': 'G#', 'G#': 'Ab',
                'Bb': 'A#', 'A#': 'Bb',
                'Db': 'C#', 'C#': 'Db'
            };
            return enharmonicPairs[note1] === note2 || enharmonicPairs[note2] === note1;
        }

        function getToneType(note, chord) {
            const tones = chordTones[chord];
            if (!tones || !note) return null;
            
            // 1. コードに定義されているトーンを優先的にチェック（異名同音も考慮）
            if (note === tones.root || isEnharmonicEquivalent(note, tones.root)) return 'root';
            if (note === tones.third || isEnharmonicEquivalent(note, tones.third)) return 'third';
            // fifthはdim5/aug5の前にチェック（通常の5thの場合）
            if (tones.fifth && (note === tones.fifth || isEnharmonicEquivalent(note, tones.fifth))) return 'fifth';
            // dim5とaug5はfifthの後にチェック（dim5/aug5が優先される）
            if (tones.dim5 && (note === tones.dim5 || isEnharmonicEquivalent(note, tones.dim5))) return 'dim5';
            if (tones.aug5 && (note === tones.aug5 || isEnharmonicEquivalent(note, tones.aug5))) return 'aug5';
            if (tones.seventh && (note === tones.seventh || isEnharmonicEquivalent(note, tones.seventh))) return 'seventh';
            if (tones.sus2 && (note === tones.sus2 || isEnharmonicEquivalent(note, tones.sus2))) return 'sus2';
            if (tones.sus4 && (note === tones.sus4 || isEnharmonicEquivalent(note, tones.sus4))) return 'sus4';
            if (tones.ninth && (note === tones.ninth || isEnharmonicEquivalent(note, tones.ninth))) return 'ninth';
            if (tones.sixth && (note === tones.sixth || isEnharmonicEquivalent(note, tones.sixth))) return 'sixth';
            
            // 2. コードに7thが定義されていない場合のみ、ルートから計算した7thを返す
            // これにより、メジャー/マイナーコードでも7thを表示できる
            // メジャーコードの場合はDominant 7th（10半音）、マイナーコードの場合はMinor 7th（10半音）を優先
            if (tones.root && !tones.seventh) {
                const rootSemitone = noteToSemitone[tones.root];
                const noteSemitone = noteToSemitone[note];
                
                // 音名がマッピングに存在することを確認
                if (rootSemitone !== undefined && noteSemitone !== undefined) {
                    const interval = (noteSemitone - rootSemitone + 12) % 12;
                    
                    // 既に他のトーンとして認識されている場合は除外（異名同音も考慮）
                    const isOtherTone = isEnharmonicEquivalent(note, tones.root) || 
                                       isEnharmonicEquivalent(note, tones.third) || 
                                       isEnharmonicEquivalent(note, tones.fifth) ||
                                       (tones.dim5 && isEnharmonicEquivalent(note, tones.dim5)) ||
                                       (tones.aug5 && isEnharmonicEquivalent(note, tones.aug5)) ||
                                       (tones.sus2 && isEnharmonicEquivalent(note, tones.sus2)) ||
                                       (tones.sus4 && isEnharmonicEquivalent(note, tones.sus4));
                    
                    if (isOtherTone) {
                        return null;
                    }
                    
                    // メジャーコード（thirdが存在し、♭3rdでない）の場合はDominant 7th（10半音）のみ
                    // マイナーコード（thirdが♭3rd）の場合もMinor 7th（10半音）のみ
                    // Major 7th（11半音）は通常、明示的にmaj7と指定された場合のみ使用
                    if (interval === 10) {
                        // Minor 7th / Dominant 7th（10半音）
                        return 'seventh';
                    }
                    // interval === 11 (Major 7th) は計算しない（maj7として明示的に定義されている場合のみ表示）
                }
            }
            
            return null;
        }

        // コードトーンを囲む図形を描画
        function drawToneOutlines(svg, tonePositions, displayMode, tones) {
            // 表示するトーンタイプを決定
            let toneTypes = [];
            if (displayMode === 'triad') {
                if (tones.sus2) toneTypes = ['root', 'sus2', 'fifth'];
                else if (tones.sus4) toneTypes = ['root', 'sus4', 'fifth'];
                else if (tones.dim5) toneTypes = ['root', 'third', 'dim5'];
                else if (tones.aug5) toneTypes = ['root', 'third', 'aug5'];
                else toneTypes = ['root', 'third', 'fifth'];
            } else if (displayMode === 'seventh') {
                if (tones.seventh) toneTypes = ['root', 'third', 'fifth', 'seventh'];
                else if (tones.dim5) toneTypes = ['root', 'third', 'dim5'];
                else if (tones.aug5) toneTypes = ['root', 'third', 'aug5'];
                else toneTypes = ['root', 'third', 'fifth'];
            } else {
                // 全ポジション: 利用可能なすべてのトーン
                toneTypes = Object.keys(tonePositions).filter(key => tonePositions[key] && tonePositions[key].length > 0);
            }
            
            // 各トーンタイプのすべてのポジションを1つのグループとして収集
            const allPositions = [];
            toneTypes.forEach(type => {
                if (tonePositions[type] && tonePositions[type].length > 0) {
                    tonePositions[type].forEach(pos => {
                        allPositions.push({ ...pos, type });
                    });
                }
            });
            
            if (allPositions.length < 2) return;
            
            // 近接するポジションをグループ化（同じコードフォーム内）
            const groups = findChordFormGroups(allPositions, toneTypes);
            
            groups.forEach((group) => {
                if (group.length < 2) return;
                
                // ルートを起点として、コードフォームに沿って並べ替え
                const sortedGroup = sortByChordForm(group, toneTypes, tonePositions);
                
                if (sortedGroup.length < 2) return;
                
                // コードフォームに沿った囲みを描画（角を丸く、内側にマージン）
                drawRoundedOutline(svg, sortedGroup);
            });
        }
        
        // コードフォームごとにグループ化（R, 3rd, 5thなどが1つのグループ）
        function findChordFormGroups(allPositions, toneTypes) {
            const groups = [];
            const used = new Set();
            
            // 各ポジションについて、同じコードフォーム内の他のトーンを探す
            allPositions.forEach(pos => {
                const key = `${pos.string}-${pos.fret}`;
                if (used.has(key)) return;
                
                const group = [pos];
                used.add(key);
                
                // 同じコードフォーム内の他のトーンを探す
                // 近接する範囲内（6フレット、4弦以内）で、必要なトーンタイプがすべて揃っているか確認
                const fretRange = 6;
                const stringRange = 4;
                
                // このポジションを中心に、必要なトーンタイプがすべて揃っているグループを探す
                const nearbyPositions = allPositions.filter(other => {
                    const otherKey = `${other.string}-${other.fret}`;
                    if (used.has(otherKey)) return false;
                    
                    const fretDiff = Math.abs(pos.fret - other.fret);
                    const stringDiff = Math.abs(pos.string - other.string);
                    return fretDiff <= fretRange && stringDiff <= stringRange;
                });
                
                // 必要なトーンタイプがすべて揃っているか確認
                const foundTypes = new Set([pos.type]);
                nearbyPositions.forEach(other => {
                    foundTypes.add(other.type);
                });
                
                // 必要なトーンタイプがすべて揃っている場合、グループに追加
                const hasAllTypes = toneTypes.every(type => foundTypes.has(type));
                
                if (hasAllTypes) {
                    // 各トーンタイプから最も近いポジションを1つずつ選ぶ
                    const selectedPositions = [pos];
                    toneTypes.forEach(type => {
                        if (type === pos.type) return; // 既に追加済み
                        
                        const candidates = nearbyPositions.filter(p => p.type === type);
                        if (candidates.length > 0) {
                            // 既に選択されたポジションに最も近いものを選ぶ
                            let closest = null;
                            let minDist = Infinity;
                            
                            candidates.forEach(candidate => {
                                selectedPositions.forEach(selected => {
                                    const dist = Math.abs(candidate.string - selected.string) + 
                                                 Math.abs(candidate.fret - selected.fret);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        closest = candidate;
                                    }
                                });
                            });
                            
                            if (closest) {
                                selectedPositions.push(closest);
                                used.add(`${closest.string}-${closest.fret}`);
                            }
                        }
                    });
                    
                    if (selectedPositions.length >= 2) {
                        groups.push(selectedPositions);
                    }
                }
            });
            
            return groups;
        }
        
        // ルートを起点として、コードフォームに沿って並べ替え
        function sortByChordForm(group, toneTypes, tonePositions) {
            // ルートを探す（typeプロパティがある場合はそれを使用）
            const roots = group.filter(p => {
                if (p.type === 'root') return true;
                // typeプロパティがない場合は、tonePositionsで確認
                return tonePositions.root && tonePositions.root.some(r => r.string === p.string && r.fret === p.fret);
            });
            
            if (roots.length === 0) {
                // ルートがない場合は、最も低いフレットの位置を起点にする
                group.sort((a, b) => {
                    if (a.fret !== b.fret) return a.fret - b.fret;
                    return a.string - b.string;
                });
                return group;
            }
            
            // ルートを起点として、トーンタイプの順序で並べ替え
            const root = roots[0];
            const sorted = [root];
            const used = new Set([`${root.string}-${root.fret}`]);
            
            // トーンタイプの順序に従って追加（ルート以外）
            toneTypes.forEach(type => {
                if (type === 'root') return;
                
                const candidates = group.filter(p => {
                    const key = `${p.string}-${p.fret}`;
                    if (used.has(key)) return false;
                    return p.type === type;
                });
                
                if (candidates.length > 0) {
                    // 既に追加されたポジションに最も近いものを選ぶ
                    let closest = null;
                    let minDist = Infinity;
                    
                    candidates.forEach(candidate => {
                        sorted.forEach(selected => {
                            const dist = Math.abs(candidate.string - selected.string) + 
                                         Math.abs(candidate.fret - selected.fret);
                            if (dist < minDist) {
                                minDist = dist;
                                closest = candidate;
                            }
                        });
                    });
                    
                    if (closest) {
                        sorted.push(closest);
                        used.add(`${closest.string}-${closest.fret}`);
                    }
                }
            });
            
            return sorted;
        }
        
        // 角を丸くした囲みを描画（内側にマージン）
        function drawRoundedOutline(svg, positions) {
            if (positions.length < 2) return;
            
            const margin = 18; // コードトーンの円の半径 + マージン
            const cornerRadius = 8; // 角の丸み
            
            // 各位置の周りにマージンを追加した点を計算
            const expandedPoints = positions.map(pos => {
                // 隣接する点との関係を考慮してマージンを追加
                return {
                    x: pos.x,
                    y: pos.y,
                    margin: margin
                };
            });
            
            // パスを構築（角を丸く）
            let pathData = '';
            
            if (positions.length === 2) {
                // 2点の場合は線を描画
                const p1 = expandedPoints[0];
                const p2 = expandedPoints[1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // 各点の周りに円を描く
                pathData = `M ${p1.x + Math.cos(angle + Math.PI / 2) * margin},${p1.y + Math.sin(angle + Math.PI / 2) * margin} ` +
                          `A ${margin},${margin} 0 0 1 ${p1.x + Math.cos(angle - Math.PI / 2) * margin},${p1.y + Math.sin(angle - Math.PI / 2) * margin} ` +
                          `L ${p2.x + Math.cos(angle - Math.PI / 2) * margin},${p2.y + Math.sin(angle - Math.PI / 2) * margin} ` +
                          `A ${margin},${margin} 0 0 1 ${p2.x + Math.cos(angle + Math.PI / 2) * margin},${p2.y + Math.sin(angle + Math.PI / 2) * margin} Z`;
            } else {
                // 3点以上の場合は閉じたパスを描画
                const points = expandedPoints.map(p => ({ x: p.x, y: p.y }));
                
                // 各点の周りにマージンを追加した形状を作成
                pathData = buildRoundedPath(points, margin, cornerRadius);
            }
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('fill', 'rgba(255, 255, 255, 0.15)');
            path.setAttribute('stroke', 'rgba(255, 255, 255, 0.6)');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('stroke-linejoin', 'round');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-dasharray', '5,5');
            
            // コードトーンの下に配置
            svg.insertBefore(path, svg.firstChild);
        }
        
        // 角を丸くしたパスを構築
        function buildRoundedPath(points, margin, cornerRadius) {
            if (points.length < 3) return '';
            
            let path = '';
            const n = points.length;
            
            for (let i = 0; i < n; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % n];
                const p0 = points[(i - 1 + n) % n];
                
                // 各点から外側への方向を計算
                const angle1 = Math.atan2(p1.y - p0.y, p1.x - p0.x);
                const angle2 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const bisectAngle = (angle1 + angle2) / 2;
                
                // マージンを追加した位置を計算
                const offsetX = Math.cos(bisectAngle + Math.PI / 2) * margin;
                const offsetY = Math.sin(bisectAngle + Math.PI / 2) * margin;
                
                const x = p1.x + offsetX;
                const y = p1.y + offsetY;
                
                if (i === 0) {
                    path += `M ${x},${y} `;
                } else {
                    // 前の点から現在の点への線（角を丸く）
                    const prevP = points[(i - 1 + n) % n];
                    const prevAngle1 = Math.atan2(prevP.y - points[(i - 2 + n) % n].y, prevP.x - points[(i - 2 + n) % n].x);
                    const prevAngle2 = Math.atan2(p1.y - prevP.y, p1.x - prevP.x);
                    const prevBisect = (prevAngle1 + prevAngle2) / 2;
                    const prevX = prevP.x + Math.cos(prevBisect + Math.PI / 2) * margin;
                    const prevY = prevP.y + Math.sin(prevBisect + Math.PI / 2) * margin;
                    
                    // 角を丸くするための曲線
                    path += `L ${prevX},${prevY} Q ${p1.x + offsetX * 0.5},${p1.y + offsetY * 0.5} ${x},${y} `;
                }
            }
            
            path += 'Z';
            return path;
        }


        // 凸包（Convex Hull）を計算（Graham scan algorithm）
        function calculateConvexHull(points) {
            if (points.length < 3) return points;
            
            // 最も下（yが最大）で、その中で最も左（xが最小）の点を見つける
            let bottomPoint = points[0];
            for (let i = 1; i < points.length; i++) {
                if (points[i].y > bottomPoint.y || 
                    (points[i].y === bottomPoint.y && points[i].x < bottomPoint.x)) {
                    bottomPoint = points[i];
                }
            }
            
            // 各点の角度を計算してソート
            const sorted = points
                .filter(p => p !== bottomPoint)
                .map(p => ({
                    ...p,
                    angle: Math.atan2(p.y - bottomPoint.y, p.x - bottomPoint.x)
                }))
                .sort((a, b) => a.angle - b.angle);
            
            // スタックを使って凸包を構築
            const hull = [bottomPoint];
            for (let i = 0; i < sorted.length; i++) {
                while (hull.length >= 2) {
                    const p1 = hull[hull.length - 2];
                    const p2 = hull[hull.length - 1];
                    const p3 = sorted[i];
                    
                    // 右回りかどうかをチェック
                    const cross = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
                    if (cross <= 0) break;
                    hull.pop();
                }
                hull.push(sorted[i]);
            }
            
            return hull;
        }

        // 実際のギターのフレット位置を計算する関数
        // スケール長を基準に、各フレットの位置を計算（フェンダーストラトキャスター: 25.5インチ）
        function calculateRealisticFretPositions(startFret, endFret) {
            const fretPositions = {};
            // スケール長をピクセルに変換（基準として、0-24フレットの範囲を適切なサイズに）
            const baseScaleLengthPixels = 1000; // 基準となるスケール長（ピクセル）
            
            // 各フレットの位置を計算（0フレット = ナット位置 = 0）
            for (let fret = 0; fret <= endFret; fret++) {
                // fret_position(n) = scale_length * (1 - 1 / (2^(n/12)))
                const fretPosition = baseScaleLengthPixels * (1 - 1 / Math.pow(2, fret / 12));
                fretPositions[fret] = fretPosition;
            }
            
            // 表示範囲（startFretからendFret）に合わせて正規化
            const startPos = fretPositions[startFret] || 0;
            const endPos = fretPositions[endFret];
            const range = endPos - startPos;
            
            // 実際のフレット位置を、表示範囲に合わせて正規化（0からの相対位置）
            const normalizedPositions = {};
            for (let fret = startFret; fret <= endFret; fret++) {
                normalizedPositions[fret] = fretPositions[fret] - startPos;
            }
            
            return { positions: normalizedPositions, range };
        }

        // トグルスイッチから表示モードの値を取得
        function getDisplayMode() {
            const allModeToggle = document.getElementById('allModeToggle');
            const allModeLabel = document.getElementById('allModeToggleLabel');
            
            // 全ポジション表示が有効な場合（拡張コードがある場合のみ）
            if (allModeLabel && allModeLabel.style.display !== 'none' && allModeToggle.checked) {
                return 'all';
            }
            
            // セブンス表示トグルがONの場合
            const seventhModeToggle = document.getElementById('seventhModeToggle');
            if (seventhModeToggle && seventhModeToggle.checked) {
                return 'seventh';
            }
            
            // デフォルトはトライアドのみ
            return 'triad';
        }

        function generateFretboard() {
            const chord = document.getElementById('chordSelect').value;
            const startFret = parseInt(document.getElementById('startFret').value);
            const endFret = parseInt(document.getElementById('endFret').value);
            const displayMode = getDisplayMode();
            const realisticSpacing = document.getElementById('realisticFretSpacing').checked;
            const tones = chordTones[chord];
            const tuning = getCurrentTuning();
            const strings = tuning.strings;

            const container = document.getElementById('fretboard');
            container.innerHTML = '';

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', 'auto');
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            
            const fretCount = endFret - startFret + 1;
            const stringSpacing = 50; // 弦の間隔を大きく
            const baseFretSpacing = 60; // 基本フレット間の距離
            
            // 実在のギターのフレット間隔を使用するかどうか
            let fretPositions = {};
            let fretSpacing = baseFretSpacing;
            
            if (realisticSpacing) {
                const fretCalc = calculateRealisticFretPositions(startFret, endFret);
                // 実際の間隔を計算しつつ、表示幅を適切に調整
                const scaleFactor = (baseFretSpacing * (fretCount - 1)) / fretCalc.range;
                // オブジェクトの各フレット位置をスケール
                for (let fret = startFret; fret <= endFret; fret++) {
                    fretPositions[fret] = fretCalc.positions[fret] * scaleFactor;
                }
            } else {
                // 等間隔の場合
                for (let f = 0; f <= fretCount; f++) {
                    fretPositions[startFret + f] = f * baseFretSpacing;
                }
            }
            
            const titleY = 25; // コード名のY位置（上に移動）
            const fretNumberY = 45; // フレット番号のY位置（コード名との間隔を広げる）
            const topMargin = 70; // 上部マージン（指板の開始位置）
            const leftMargin = 120; // 左側マージン（弦名用のスペースを増やす）
            const rightMargin = 50;
            const bottomMargin = 50; // 下部マージン（ポジションマーク用のスペース）
            
            // 総幅を計算（実際のフレット位置を使用）- 終了フレットの位置まで
            const maxFretXPos = realisticSpacing ? fretPositions[endFret] : (fretCount - 1) * fretSpacing;
            const totalWidth = leftMargin + maxFretXPos + rightMargin;
            const totalHeight = topMargin + (strings.length - 1) * stringSpacing + bottomMargin;
            
            svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
            
            // フレット位置を取得するヘルパー関数
            const getFretX = (fretNum) => {
                if (fretPositions[fretNum] !== undefined) {
                    return leftMargin + fretPositions[fretNum];
                }
                // フォールバック（等間隔）
                return leftMargin + (fretNum - startFret) * fretSpacing;
            };
            
            // フレット間の中間位置を取得するヘルパー関数（押弦位置）
            const getFretMiddleX = (fretNum) => {
                if (fretNum === 0) {
                    return leftMargin - 30; // 開放弦は弦名表示領域
                }
                const currentX = getFretX(fretNum);
                const prevX = getFretX(fretNum - 1);
                return (prevX + currentX) / 2; // 前のフレットと現在のフレットの中間
            };

            // フレット線を描画
            for (let f = 0; f < fretCount; f++) {
                const fretNum = startFret + f;
                const x = getFretX(fretNum);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', topMargin);
                line.setAttribute('x2', x);
                line.setAttribute('y2', topMargin + (strings.length - 1) * stringSpacing);
                line.setAttribute('stroke', '#666');
                line.setAttribute('stroke-width', f === 0 ? '3' : '1');
                svg.appendChild(line);
            }
            // 終了フレットの境界線を描画
            const endFretX = getFretX(endFret);
            const endLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            endLine.setAttribute('x1', endFretX);
            endLine.setAttribute('y1', topMargin);
            endLine.setAttribute('x2', endFretX);
            endLine.setAttribute('y2', topMargin + (strings.length - 1) * stringSpacing);
            endLine.setAttribute('stroke', '#666');
            endLine.setAttribute('stroke-width', '1');
            svg.appendChild(endLine);

            // 弦を描画
            const endX = getFretX(endFret);
            for (let s = 0; s < strings.length; s++) {
                const y = topMargin + s * stringSpacing;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', leftMargin);
                line.setAttribute('y1', y);
                line.setAttribute('x2', endX);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#888');
                line.setAttribute('stroke-width', '2.5'); // 弦の太さを少し太く
                svg.appendChild(line);

                // 開放弦の音名（左側に十分なスペースを確保）
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', leftMargin - 30);
                text.setAttribute('y', y + 6);
                text.setAttribute('fill', '#e0e0e0');
                text.setAttribute('font-size', '16');
                text.setAttribute('text-anchor', 'middle');
                text.textContent = strings[s];
                svg.appendChild(text);
            }

            // フレット番号（上部に十分なスペースを確保）
            for (let f = 0; f < fretCount; f++) {
                const fretNum = startFret + f;
                const x = getFretX(fretNum);
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', fretNumberY);
                text.setAttribute('fill', '#888');
                text.setAttribute('font-size', '14');
                text.setAttribute('text-anchor', 'middle');
                text.textContent = fretNum === 0 ? '0' : fretNum;
                svg.appendChild(text);
            }
            // 終了フレットの番号を表示
            const endFretNumX = getFretX(endFret);
            const endFretText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            endFretText.setAttribute('x', endFretNumX);
            endFretText.setAttribute('y', fretNumberY);
            endFretText.setAttribute('fill', '#888');
            endFretText.setAttribute('font-size', '14');
            endFretText.setAttribute('text-anchor', 'middle');
            endFretText.textContent = endFret.toString();
            svg.appendChild(endFretText);
            
            // ポジションマークを描画（3, 5, 7, 9, 12, 15, 17, 19, 21, 24フレット）
            // 指板の表面（弦と弦の間）に配置（フェンダーギターと同じ見た目）
            const positionMarks = [3, 5, 7, 9, 12, 15, 17, 19, 21, 24];
            
            // ポジションマークの配置位置：弦と弦の間の中央
            // 通常は3弦と4弦の間に配置
            const stringIndex1 = 2; // 3弦（0-indexedなので2）
            const stringIndex2 = 3; // 4弦（0-indexedなので3）
            const markYBetween = topMargin + (stringIndex1 * stringSpacing + stringIndex2 * stringSpacing) / 2;
            
            // 12フレットと24フレット用の2つのマークの位置（2弦、5弦にかかるぐらいに内側へ）
            // 1弦と2弦の間ではなく、2弦の位置に近い位置（2弦に少しかかる）
            const stringIndex1_double = 1; // 2弦
            const markY_double_1 = topMargin + stringIndex1_double * stringSpacing - 8; // 2弦の少し上（2弦にかかる）
            // 5弦と6弦の間ではなく、5弦の位置に近い位置（5弦に少しかかる）
            const stringIndex3_double = 4; // 5弦
            const markY_double_2 = topMargin + stringIndex3_double * stringSpacing + 8; // 5弦の少し下（5弦にかかる）
            
            const dotRadius = 16; // サイズを倍に（直径32）
            // ポジションマークの不透明度をスライダーから取得（0-100の値を0-1に変換）
            const positionMarkOpacityValue = parseInt(document.getElementById('positionMarkOpacity').value) / 100;
            
            positionMarks.forEach(fretNum => {
                if (fretNum >= startFret && fretNum <= endFret) {
                    // フレットとフレットの中間位置（実際の押弦位置）に配置
                    const markX = getFretMiddleX(fretNum);
                    
                    // 12フレットと24フレットは2つのマーク（上下に配置、2弦と5弦にかかる）
                    if (fretNum === 12 || fretNum === 24) {
                        const dot1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        dot1.setAttribute('cx', markX);
                        dot1.setAttribute('cy', markY_double_1);
                        dot1.setAttribute('r', dotRadius);
                        dot1.setAttribute('fill', '#bbb');
                        dot1.setAttribute('opacity', positionMarkOpacityValue);
                        svg.appendChild(dot1);
                        
                        const dot2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        dot2.setAttribute('cx', markX);
                        dot2.setAttribute('cy', markY_double_2);
                        dot2.setAttribute('r', dotRadius);
                        dot2.setAttribute('fill', '#bbb');
                        dot2.setAttribute('opacity', positionMarkOpacityValue);
                        svg.appendChild(dot2);
                    } else {
                        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        dot.setAttribute('cx', markX);
                        dot.setAttribute('cy', markYBetween);
                        dot.setAttribute('r', dotRadius);
                        dot.setAttribute('fill', '#bbb');
                        dot.setAttribute('opacity', positionMarkOpacityValue);
                        svg.appendChild(dot);
                    }
                }
            });

            // コードトーンの位置を収集（囲み用）
            const tonePositions = {
                root: [],
                third: [],
                fifth: [],
                seventh: [],
                dim5: [],
                aug5: [],
                sus2: [],
                sus4: [],
                ninth: [],
                sixth: []
            };

            // コードトーンを描画
            for (let s = 0; s < strings.length; s++) {
                for (let f = 0; f < fretCount; f++) {
                    const fretNum = startFret + f;
                    const note = getNoteAtPosition(s, fretNum);
                    const toneType = getToneType(note, chord);

                    if (toneType) {
                        // 表示モードのチェック
                        // サスペンドコード（sus2, sus4）はトライアドの一部として扱う
                        // ディミニッシュ（dim5）とオーギュメント（aug5）もトライアドの一部として扱う
                        const isSusTone = ['sus2', 'sus4'].includes(toneType);
                        const isDimAugTone = ['dim5', 'aug5'].includes(toneType);
                        const isSeventhTone = toneType === 'seventh';
                        const isOtherExtendedTone = ['ninth', 'sixth'].includes(toneType);
                        
                        let shouldDisplay = false;
                        
                        // トライアドモード: ルート、3rd、5th、sus2/sus4、dim5/aug5を表示
                        if (displayMode === 'triad') {
                            if (isOtherExtendedTone || isSeventhTone) {
                                continue; // ninth、sixth、7thはスキップ
                            }
                            shouldDisplay = true; // dim5、aug5、sus2、sus4は表示（トライアドの一部）
                        }
                        // セブンス含むモード: ルート、3rd、5th、7th、sus2/sus4、dim5/aug5を表示
                        else if (displayMode === 'seventh') {
                            if (isOtherExtendedTone) {
                                continue; // ninth、sixthはスキップ
                            }
                            shouldDisplay = true; // 7thは表示（コードに7thが定義されていなくても、ルートに対して7thが存在すれば表示）
                        }
                        // 全ポジション: すべて表示
                        else if (displayMode === 'all') {
                            shouldDisplay = true;
                        }
                        
                        if (shouldDisplay) {
                            // フレットとフレットの中間（実際の押弦位置）に配置
                            const x = getFretMiddleX(fretNum);
                            const y = topMargin + s * stringSpacing;

                            // 位置を記録（囲み用）
                            if (tonePositions[toneType]) {
                                tonePositions[toneType].push({ x, y, string: s, fret: fretNum });
                            }

                            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            circle.setAttribute('cx', x);
                            circle.setAttribute('cy', y);
                            circle.setAttribute('r', '14'); // コードトーンの円を少し大きく
                            
                            const colors = {
                                'root': '#ff4444',
                                'third': '#4444ff',
                                'fifth': '#44ff44',
                                'seventh': '#ffff44',
                                'dim5': '#ff44ff',
                                'aug5': '#ff8844',
                                'sus2': '#44ffff',
                                'sus4': '#ffaa44',
                                'ninth': '#aa44ff',
                                'sixth': '#44ffaa'
                            };
                            
                            circle.setAttribute('fill', colors[toneType]);
                            circle.setAttribute('stroke', '#fff');
                            circle.setAttribute('stroke-width', '2');
                            svg.appendChild(circle);

                            // 音名を表示
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', x);
                            text.setAttribute('y', y + 5);
                            text.setAttribute('fill', '#000');
                            text.setAttribute('font-size', '11');
                            text.setAttribute('font-weight', 'bold');
                            text.setAttribute('text-anchor', 'middle');
                            text.textContent = note;
                            svg.appendChild(text);
                        }
                    }
                }
            }

            // コードトーンを囲む機能（一旦無効化）
            // const showOutline = document.getElementById('showOutline').checked;
            // if (showOutline) {
            //     drawToneOutlines(svg, tonePositions, displayMode, tones);
            // }

            // コード名を表示
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', totalWidth / 2);
            title.setAttribute('y', titleY);
            title.setAttribute('fill', '#e0e0e0');
            title.setAttribute('font-size', '22');
            title.setAttribute('font-weight', 'bold');
            title.setAttribute('text-anchor', 'middle');
            title.textContent = `${chord} - ${Object.values(tones).join(', ')}`;
            svg.appendChild(title);

            container.appendChild(svg);
            
            // 表示されているトーンタイプを収集して下部のインターバル表示を更新
            const legendModeToggle = document.getElementById('legendModeToggle');
            const legendMode = legendModeToggle && legendModeToggle.checked ? 'displayedOnly' : 'all';
            updateIntervalDisplay(displayMode, tones, tonePositions, legendMode);
        }
        
        // 下部のインターバル表示を更新
        function updateIntervalDisplay(displayMode, tones, tonePositions, legendMode) {
            // 実際に指板上に表示されているトーンタイプを取得（tonePositionsから）
            // これにより、指板の表示と凡例が常に一致する
            const displayedTypes = Object.keys(tonePositions).filter(type => 
                tonePositions[type] && tonePositions[type].length > 0
            );
            
            // 凡例表示モードに応じて処理
            const legendItems = document.querySelectorAll('.legend-item');
            
            // まず全ての項目をリセット（表示状態とスタイルを初期化）
            legendItems.forEach(item => {
                const dot = item.querySelector('.legend-dot');
                const span = item.querySelector('span');
                if (!dot || !span) return;
                
                // displayを常にリセット（コード切り替え時に前の状態が残らないように）
                item.style.display = 'flex';
                
                // スタイルもリセット
                dot.style.opacity = '';
                span.style.opacity = '';
                span.style.fontWeight = '';
            });
            
            if (legendMode === 'displayedOnly') {
                // 表示されているもののみを表示（非表示のものは完全に非表示）
                legendItems.forEach(item => {
                    const dot = item.querySelector('.legend-dot');
                    const span = item.querySelector('span');
                    if (!dot || !span) return;
                    
                    const toneType = getToneTypeFromLegend(span.textContent);
                    if (toneType && displayedTypes.includes(toneType)) {
                        // 表示されている場合は表示
                        item.style.display = 'flex';
                    } else {
                        // 表示されていない場合は非表示
                        item.style.display = 'none';
                    }
                });
            } else {
                // 全て表示（活性/非活性で区別）
                legendItems.forEach(item => {
                    const dot = item.querySelector('.legend-dot');
                    const span = item.querySelector('span');
                    if (!dot || !span) return;
                    
                    const toneType = getToneTypeFromLegend(span.textContent);
                    if (toneType && displayedTypes.includes(toneType)) {
                        // 表示されている場合は活性化（色を濃く、不透明度を上げる）
                        dot.style.opacity = '1';
                        span.style.opacity = '1';
                        span.style.fontWeight = 'bold';
                    } else {
                        // 表示されていない場合はグレーアウト
                        dot.style.opacity = '0.3';
                        span.style.opacity = '0.3';
                        span.style.fontWeight = 'normal';
                    }
                });
            }
        }
        
        // レジェンドのテキストからトーンタイプを取得
        function getToneTypeFromLegend(text) {
            const mapping = {
                'ルート': 'root',
                '3rd': 'third',
                '5th': 'fifth',
                '7th': 'seventh',
                '♭5th': 'dim5',
                '#5th': 'aug5',
                '2nd': 'sus2',
                '4th': 'sus4',
                '9th': 'ninth',
                '6th': 'sixth'
            };
            return mapping[text] || null;
        }

        function downloadSVG() {
            const svg = document.querySelector('#fretboard svg');
            if (!svg) return;
            
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `fretboard-${document.getElementById('chordSelect').value}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadPNG() {
            const svg = document.querySelector('#fretboard svg');
            if (!svg) return;

            const svgData = new XMLSerializer().serializeToString(svg);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = function() {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `fretboard-${document.getElementById('chordSelect').value}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            };
            
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }

        // コード選択時に表示モードオプションを更新
        function updateDisplayModeOptions() {
            const chord = document.getElementById('chordSelect').value;
            const tones = chordTones[chord];
            const allModeLabel = document.getElementById('allModeToggleLabel');
            const allModeToggle = document.getElementById('allModeToggle');
            
            if (!tones) {
                if (allModeLabel) allModeLabel.style.display = 'none';
                return;
            }
            
            // 拡張トーン（ninth、sixth）がある場合のみ「全ポジション表示」トグルを表示
            const hasExtendedTones = (tones.ninth !== undefined) || (tones.sixth !== undefined);
            
            if (hasExtendedTones) {
                if (allModeLabel) allModeLabel.style.display = 'flex';
            } else {
                if (allModeLabel) allModeLabel.style.display = 'none';
                // 全ポジション表示がONの場合はOFFに戻す
                if (allModeToggle && allModeToggle.checked) {
                    allModeToggle.checked = false;
                }
            }
        }
        
        // コード選択のイベントリスナーを設定
        document.getElementById('chordSelect').addEventListener('change', function() {
            updateDisplayModeOptions();
            generateFretboard();
        });
        
        // フレット範囲の変更時に自動生成
        document.getElementById('startFret').addEventListener('change', generateFretboard);
        document.getElementById('startFret').addEventListener('input', generateFretboard);
        document.getElementById('endFret').addEventListener('change', generateFretboard);
        document.getElementById('endFret').addEventListener('input', generateFretboard);
        
        // 表示モードの変更時に自動生成（トグルスイッチ）
        document.getElementById('seventhModeToggle').addEventListener('change', generateFretboard);
        const allModeToggle = document.getElementById('allModeToggle');
        if (allModeToggle) {
            allModeToggle.addEventListener('change', function() {
                // 全ポジション表示がONの場合、セブンス表示を自動でOFFにしない（両方ONでも可）
                generateFretboard();
            });
        }
        
        // チューニング変更時に自動生成
        document.getElementById('tuningSelect').addEventListener('change', generateFretboard);
        
        // フレット間隔オプション変更時に自動生成
        document.getElementById('realisticFretSpacing').addEventListener('change', generateFretboard);
        
        // 凡例表示モード変更時に自動生成（トグルスイッチ）
        const legendModeToggle = document.getElementById('legendModeToggle');
        if (legendModeToggle) {
            legendModeToggle.addEventListener('change', generateFretboard);
        }
        
        // ポジションマーク濃度スライダーのイベントリスナー
        const positionMarkOpacitySlider = document.getElementById('positionMarkOpacity');
        const positionMarkOpacityValueDisplay = document.getElementById('positionMarkOpacityValue');
        
        // スライダーの値を表示
        positionMarkOpacitySlider.addEventListener('input', function() {
            positionMarkOpacityValueDisplay.textContent = this.value + '%';
            generateFretboard(); // スライダー変更時に指板を再生成
        });
        
        // 初期化時に実行
        updateDisplayModeOptions();
        
        // 初期表示
        generateFretboard();
        
        // テストコード: 凡例と指板の表示の一致を確認
        function testLegendConsistency() {
            const tests = [];
            const chords = Object.keys(chordTones);
            
            // 代表的なコードと表示モードの組み合わせでテスト
            const testCases = [
                { chord: 'A', displayMode: 'triad' },
                { chord: 'A', displayMode: 'seventh' },
                { chord: 'A7', displayMode: 'seventh' },
                { chord: 'Am', displayMode: 'triad' },
                { chord: 'Asus2', displayMode: 'triad' },
                { chord: 'Adim', displayMode: 'triad' },
                { chord: 'Aaug', displayMode: 'triad' },
                { chord: 'A9', displayMode: 'all' }
            ];
            
            for (const testCase of testCases) {
                const { chord, displayMode } = testCase;
                const tones = chordTones[chord];
                if (!tones) continue;
                
                // 実際の表示ロジックに基づいて、どのトーンタイプが表示されるかを判断
                const mockTonePositions = {};
                
                // コードに定義されているトーンタイプを確認
                const toneTypeMap = {
                    'root': 'root',
                    'third': 'third',
                    'fifth': 'fifth',
                    'seventh': 'seventh',
                    'dim5': 'dim5',
                    'aug5': 'aug5',
                    'sus2': 'sus2',
                    'sus4': 'sus4',
                    'ninth': 'ninth',
                    'sixth': 'sixth'
                };
                
                for (const [key, mappedType] of Object.entries(toneTypeMap)) {
                    if (tones[key]) {
                        let shouldBeDisplayed = false;
                        
                        if (displayMode === 'triad') {
                            shouldBeDisplayed = ['root', 'third', 'fifth', 'sus2', 'sus4', 'dim5', 'aug5'].includes(mappedType);
                        } else if (displayMode === 'seventh') {
                            shouldBeDisplayed = ['root', 'third', 'fifth', 'seventh', 'sus2', 'sus4', 'dim5', 'aug5'].includes(mappedType);
                        } else {
                            shouldBeDisplayed = true;
                        }
                        
                        if (shouldBeDisplayed) {
                            mockTonePositions[mappedType] = [{x: 0, y: 0}]; // ダミーデータ
                        }
                    }
                }
                
                // updateIntervalDisplayの動作をテスト
                const displayedTypes = Object.keys(mockTonePositions).filter(type => 
                    mockTonePositions[type] && mockTonePositions[type].length > 0
                );
                
                tests.push({
                    chord,
                    displayMode,
                    expectedTypes: Object.keys(mockTonePositions),
                    actualTypes: displayedTypes,
                    pass: JSON.stringify(displayedTypes.sort()) === JSON.stringify(Object.keys(mockTonePositions).sort())
                });
            }
            
            // テスト結果をコンソールに出力
            if (typeof console !== 'undefined' && console.log) {
                const passed = tests.filter(t => t.pass).length;
                const failed = tests.filter(t => !t.pass).length;
                console.log(`凡例一貫性テスト: ${passed} passed, ${failed} failed (total: ${tests.length})`);
                if (failed > 0) {
                    console.warn('失敗したテスト:', tests.filter(t => !t.pass));
                }
            }
            
            return tests;
        }
        
        // 開発モードの場合のみテストを実行（URLパラメータで制御: ?test=true）
        if (typeof URLSearchParams !== 'undefined' && new URLSearchParams(window.location.search).get('test') === 'true') {
            // ページロード後にテストを実行
            setTimeout(() => {
                testLegendConsistency();
            }, 1000);
        }
    </script>
</body>
</html>

